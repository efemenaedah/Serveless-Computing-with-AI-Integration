<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Family Photo Gallery - Demo Mode</title>
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
        }

        /* Gradient header with professional styling */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem 1rem;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 300;
            margin-bottom: 0.5rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 1.5rem;
        }

        /* Enhanced Button styling with improved hover effects */
        .btn {
            display: inline-block;
            padding: 14px 28px;
            margin: 0 8px;
            background-color: rgba(255, 255, 255, 0.15);
            color: white;
            text-decoration: none;
            border: 2px solid rgba(255, 255, 255, 0.25);
            border-radius: 8px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            user-select: none;
            touch-action: manipulation;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .btn:hover {
            background-color: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-3px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.25);
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:active {
            transform: translateY(-1px);
            transition: transform 0.1s ease;
        }

        .btn-primary {
            background-color: #28a745;
            border-color: #28a745;
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }

        .btn-primary:hover {
            background-color: #218838;
            border-color: #1e7e34;
            box-shadow: 0 8px 20px rgba(40, 167, 69, 0.4);
            transform: translateY(-3px);
        }

        .btn-primary:active {
            background-color: #1e7e34;
            transform: translateY(-1px);
        }

        /* Main container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }

        /* Enhanced Architecture toggle section */
        .architecture-section {
            margin-bottom: 2rem;
            text-align: center;
        }

        .architecture-diagram {
            display: none;
            background: white;
            border-radius: 12px;
            padding: 2.5rem;
            margin-top: 1.5rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            border: 1px solid #e9ecef;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .architecture-diagram.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        .architecture-diagram h3 {
            color: #2c3e50;
            margin-bottom: 1rem;
            font-size: 1.5rem;
        }

        .architecture-diagram p {
            color: #6c757d;
            margin-bottom: 1.5rem;
            font-size: 1.1rem;
        }

        /* Enhanced flow visualization container */
        .flow-container {
            margin-top: 2rem;
        }

        .flow-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding: 0.75rem 1rem;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .flow-title {
            font-weight: 600;
            color: #2c3e50;
            font-size: 1.1rem;
        }

        .flow-timing {
            font-size: 0.9rem;
            color: #6c757d;
            font-weight: 500;
        }

        .flow-timing.active {
            color: #ffc107;
            animation: pulse-text 1.5s ease-in-out infinite alternate;
        }

        .flow-timing.complete {
            color: #28a745;
            font-weight: 600;
        }

        @keyframes pulse-text {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }

        .flow-steps {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .step {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            font-weight: 500;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .step:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.3);
        }

        .step-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .step-status {
            font-size: 0.75rem;
            opacity: 0.9;
            margin-bottom: 0.25rem;
        }

        .step-timing {
            font-size: 0.7rem;
            opacity: 0.8;
            font-weight: 400;
        }

        .step-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: rgba(255, 255, 255, 0.3);
            transition: width 0.3s ease;
            width: 0%;
        }

        /* Enhanced step status indicators */
        .step.idle .step-progress {
            width: 0%;
            background: rgba(255, 255, 255, 0.2);
        }

        .step.active .step-progress {
            width: 100%;
            background: #ffc107;
            animation: progress-pulse 1.5s ease-in-out infinite alternate;
        }

        .step.complete .step-progress {
            width: 100%;
            background: #28a745;
        }

        .step.error .step-progress {
            width: 100%;
            background: #dc3545;
        }

        @keyframes progress-pulse {
            from { opacity: 0.6; }
            to { opacity: 1; }
        }

        /* Step connection lines */
        .step-connector {
            display: none;
            position: absolute;
            top: 50%;
            right: -0.5rem;
            width: 1rem;
            height: 2px;
            background: #dee2e6;
            transform: translateY(-50%);
            z-index: 1;
        }

        .step-connector.active {
            background: linear-gradient(90deg, #667eea, #ffc107);
            animation: flow-animation 2s ease-in-out infinite;
        }

        @keyframes flow-animation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Real-time metrics display */
        .flow-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
            padding: 1rem;
            background: rgba(102, 126, 234, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(102, 126, 234, 0.1);
        }

        .metric {
            text-align: center;
            padding: 0.75rem;
            background: white;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .metric-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 0.25rem;
        }

        .metric-label {
            font-size: 0.8rem;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .metric.active .metric-value {
            color: #ffc107;
            animation: pulse-text 1s ease-in-out infinite alternate;
        }

        .metric.complete .metric-value {
            color: #28a745;
        }

        /* Flow visualization enhancements for mobile */
        @media (max-width: 768px) {
            .flow-steps {
                grid-template-columns: 1fr;
                gap: 0.75rem;
            }
            
            .step {
                min-height: 60px;
                padding: 0.75rem;
            }
            
            .flow-metrics {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .flow-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }
        }

        /* Architecture flow step status indicators */
        .step.idle {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .step.active {
            background: linear-gradient(135deg, #ffc107 0%, #ff8c00 100%);
            animation: pulse 1.5s ease-in-out infinite alternate;
        }

        .step.complete {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .step.error {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        @keyframes pulse {
            from {
                box-shadow: 0 6px 16px rgba(255, 193, 7, 0.3);
            }
            to {
                box-shadow: 0 6px 20px rgba(255, 193, 7, 0.6);
            }
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Animation for photo cards */
        .photo-card {
            animation: fadeInUp 0.6s ease-out forwards;
            opacity: 0;
        }

        /* Enhanced Responsive CSS Grid container for photos */
        .photo-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 2rem;
            margin-top: 2rem;
            padding: 0;
            align-items: start;
        }

        /* Enhanced photo card with improved hover effects */
        .photo-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            border: 1px solid rgba(0, 0, 0, 0.04);
        }

        .photo-card::after {
            content: 'üîç';
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0.5rem;
            border-radius: 50%;
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .photo-card:hover::after {
            opacity: 1;
        }

        .photo-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 16px 32px rgba(0, 0, 0, 0.12);
            border-color: rgba(102, 126, 234, 0.2);
        }

        .photo-card:active {
            transform: translateY(-4px) scale(1.01);
            transition: all 0.1s ease;
        }

        .photo-card img {
            width: 100%;
            height: 200px;
            object-fit: cover;
        }

        .photo-card img {
            width: 100%;
            height: 220px;
            object-fit: cover;
            transition: transform 0.3s ease;
        }

        .photo-card:hover img {
            transform: scale(1.05);
        }

        .photo-info {
            padding: 1.25rem;
            position: relative;
        }

        .photo-title {
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #2c3e50;
            font-size: 1.1rem;
            line-height: 1.3;
            transition: color 0.3s ease;
        }

        .photo-card:hover .photo-title {
            color: #667eea;
        }

        .photo-meta {
            font-size: 0.9rem;
            color: #6c757d;
            line-height: 1.4;
        }

        .photo-meta div {
            margin-bottom: 0.25rem;
        }

        .photo-meta div:last-child {
            margin-bottom: 0;
        }

        /* Enhanced Loading and error states */
        .loading {
            text-align: center;
            padding: 3rem;
            color: #6c757d;
            font-size: 1.1rem;
            grid-column: 1 / -1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
        }

        /* Loading Spinner Animation */
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #e9ecef;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Loading dots animation */
        .loading-dots {
            display: inline-block;
            position: relative;
            width: 80px;
            height: 20px;
        }

        .loading-dots div {
            position: absolute;
            top: 50%;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #667eea;
            animation: loading-dots 1.2s linear infinite;
            transform: translateY(-50%);
        }

        .loading-dots div:nth-child(1) { left: 8px; animation-delay: 0s; }
        .loading-dots div:nth-child(2) { left: 32px; animation-delay: -0.4s; }
        .loading-dots div:nth-child(3) { left: 56px; animation-delay: -0.8s; }

        @keyframes loading-dots {
            0%, 80%, 100% {
                transform: translateY(-50%) scale(0);
                opacity: 0.5;
            }
            40% {
                transform: translateY(-50%) scale(1);
                opacity: 1;
            }
        }

        /* Loading progress bar */
        .loading-progress {
            width: 100%;
            max-width: 300px;
            height: 4px;
            background-color: #e9ecef;
            border-radius: 2px;
            overflow: hidden;
            margin: 1rem auto;
        }

        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 2px;
            animation: loading-progress 2s ease-in-out infinite;
        }

        @keyframes loading-progress {
            0% {
                width: 0%;
                transform: translateX(-100%);
            }
            50% {
                width: 100%;
                transform: translateX(0%);
            }
            100% {
                width: 100%;
                transform: translateX(100%);
            }
        }

        /* Loading text animation */
        .loading-text {
            font-weight: 500;
            margin-top: 1rem;
        }

        .loading-text.animated::after {
            content: '';
            animation: loading-text-dots 1.5s steps(4, end) infinite;
        }

        @keyframes loading-text-dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        /* Enhanced Error States */
        .error {
            text-align: center;
            padding: 2rem;
            color: #721c24;
            background: linear-gradient(135deg, #f8d7da 0%, #f1aeb5 100%);
            border: 1px solid #f5c6cb;
            border-radius: 12px;
            margin: 1rem 0;
            grid-column: 1 / -1;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.1);
            position: relative;
            overflow: hidden;
        }

        .error::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .error:hover {
            box-shadow: 0 6px 20px rgba(220, 53, 69, 0.2);
            transform: translateY(-2px);
        }

        .error:hover::before {
            left: 100%;
        }

        /* Error icon */
        .error-icon {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            color: #dc3545;
            display: block;
        }

        .error-message {
            font-size: 1.1rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
            line-height: 1.4;
        }

        .error-details {
            font-size: 0.9rem;
            color: #856404;
            background-color: rgba(255, 193, 7, 0.1);
            padding: 0.75rem;
            border-radius: 6px;
            margin: 1rem 0;
            border-left: 4px solid #ffc107;
        }

        /* Success state animations */
        .success-message {
            text-align: center;
            padding: 1.5rem;
            color: #155724;
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            border: 1px solid #c3e6cb;
            border-radius: 12px;
            margin: 1rem 0;
            grid-column: 1 / -1;
            animation: slideInFromTop 0.5s ease-out;
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.1);
        }

        @keyframes slideInFromTop {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-10px);
            }
        }

        /* Photo loading states */
        .photo-card.loading {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% {
                background-position: -200% 0;
            }
            100% {
                background-position: 200% 0;
            }
        }

        /* Enhanced image error states */
        .photo-card.image-error {
            border: 2px dashed #dc3545;
            background: linear-gradient(135deg, #f8d7da 0%, #f1aeb5 100%);
            position: relative;
        }

        .photo-card.image-error img {
            opacity: 0.8;
            filter: grayscale(20%);
        }

        .photo-card.image-error:hover {
            border-color: #c82333;
            transform: translateY(-4px) scale(1.01);
        }

        .photo-card.image-error .photo-title::after {
            content: ' ‚ö†Ô∏è';
            color: #dc3545;
        }

        /* Image retry overlay animations */
        .image-retry-overlay {
            animation: pulse-retry 2s ease-in-out infinite;
        }

        @keyframes pulse-retry {
            0%, 100% {
                opacity: 0.9;
            }
            50% {
                opacity: 1;
            }
        }

        /* Error recovery guidance styles */
        .error-recovery-actions {
            background: rgba(255, 193, 7, 0.1);
            border-left: 4px solid #ffc107;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }

        .error-recovery-actions ul {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }

        .error-recovery-actions li {
            margin: 0.25rem 0;
            color: #856404;
        }

        /* Technical details collapsible */
        .error-technical-details {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
            padding: 0.75rem;
            margin-top: 0.5rem;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            word-break: break-all;
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .error-technical-details summary {
            cursor: pointer;
            font-weight: 600;
            color: #495057;
            margin-bottom: 0.5rem;
        }

        .error-technical-details summary:hover {
            color: #212529;
        }

        /* Enhanced error actions */
        .error-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
            justify-content: center;
        }

        .diagnostics-btn {
            background: linear-gradient(135deg, #6f42c1 0%, #59359a 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .diagnostics-btn:hover {
            background: linear-gradient(135deg, #59359a 0%, #4c2a85 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(111, 66, 193, 0.3);
        }

        /* Diagnostic Panel Styles */
        .diagnostic-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            backdrop-filter: blur(5px);
        }

        .diagnostic-content {
            background: white;
            border-radius: 16px;
            max-width: 800px;
            max-height: 90vh;
            width: 100%;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideInUp 0.4s ease-out;
        }

        .diagnostic-header {
            background: linear-gradient(135deg, #6f42c1 0%, #59359a 100%);
            color: white;
            padding: 1.5rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .diagnostic-header h3 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 600;
        }

        .diagnostic-close {
            background: none;
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            width: 3rem;
            height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .diagnostic-close:hover {
            background-color: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .diagnostic-body {
            padding: 2rem;
            max-height: 60vh;
            overflow-y: auto;
        }

        .diagnostic-section {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: #f8f9fa;
            border-radius: 12px;
            border-left: 4px solid #6f42c1;
        }

        .diagnostic-section h4 {
            margin: 0 0 1rem 0;
            color: #2c3e50;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .diagnostic-info {
            color: #495057;
            line-height: 1.6;
        }

        .diagnostic-info ul {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }

        .diagnostic-info li {
            margin: 0.25rem 0;
        }

        .diagnostic-status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid #e9ecef;
        }

        .diagnostic-status-item:last-child {
            border-bottom: none;
        }

        .diagnostic-status-label {
            font-weight: 600;
            color: #495057;
        }

        .diagnostic-status-value {
            font-family: monospace;
            font-size: 0.9rem;
        }

        .diagnostic-status-ok {
            color: #28a745;
        }

        .diagnostic-status-warning {
            color: #ffc107;
        }

        .diagnostic-status-error {
            color: #dc3545;
        }

        .diagnostic-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid #e9ecef;
        }

        .diagnostic-action-btn {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            flex: 1;
            min-width: 150px;
        }

        .diagnostic-action-btn:hover {
            background: linear-gradient(135deg, #138496 0%, #0f6674 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(23, 162, 184, 0.3);
        }

        /* Responsive diagnostic panel */
        @media (max-width: 768px) {
            .diagnostic-panel {
                padding: 1rem;
            }

            .diagnostic-content {
                max-height: 95vh;
            }

            .diagnostic-header {
                padding: 1rem 1.5rem;
            }

            .diagnostic-header h3 {
                font-size: 1.25rem;
            }

            .diagnostic-body {
                padding: 1.5rem;
            }

            .diagnostic-section {
                padding: 1rem;
            }

            .diagnostic-actions {
                flex-direction: column;
            }

            .diagnostic-action-btn {
                min-width: auto;
            }
        }

        /* Retry button enhancements */
        .retry-btn {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 1rem;
            position: relative;
            overflow: hidden;
        }

        .retry-btn:hover {
            background: linear-gradient(135deg, #c82333 0%, #a71e2a 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(220, 53, 69, 0.3);
        }

        .retry-btn:active {
            transform: translateY(0);
        }

        .retry-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .retry-btn:hover::before {
            left: 100%;
        }

        /* Grid system utilities */
        .grid-full-width {
            grid-column: 1 / -1;
        }

        /* Ensure proper grid behavior */
        .photo-grid:empty::after {
            content: '';
            grid-column: 1 / -1;
        }

        /* Grid gap adjustments for different content densities */
        .photo-grid.dense {
            gap: 1rem;
        }

        .photo-grid.spacious {
            gap: 3rem;
        }

        /* Enhanced Responsive Design with Multiple Breakpoints */
        
        /* Large Desktop (1200px+) */
        @media (min-width: 1200px) {
            .photo-grid {
                grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
                gap: 2.5rem;
            }
            
            .container {
                padding: 3rem 2rem;
            }
        }

        /* Desktop (992px - 1199px) */
        @media (min-width: 992px) and (max-width: 1199px) {
            .photo-grid {
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
                gap: 2rem;
            }
        }

        /* Tablet (768px - 991px) */
        @media (min-width: 768px) and (max-width: 991px) {
            .photo-grid {
                grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
                gap: 1.5rem;
            }
            
            .container {
                padding: 2rem 1.5rem;
            }
        }

        /* Mobile Large (576px - 767px) */
        @media (max-width: 767px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .header p {
                font-size: 1rem;
            }
            
            .btn {
                display: block;
                margin: 8px auto;
                width: 220px;
                min-height: 48px;
                font-size: 1.1rem;
            }
            
            .photo-grid {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 1.25rem;
            }
            
            .container {
                padding: 1.5rem 1rem;
            }
            
            .photo-card {
                border-radius: 10px;
            }
        }

        /* Mobile Medium (480px - 575px) */
        @media (max-width: 575px) {
            .photo-grid {
                grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
                gap: 1rem;
            }
            
            .header {
                padding: 1.5rem 1rem;
            }
            
            .btn {
                width: 200px;
                min-height: 50px;
            }
        }

        /* Mobile Small (up to 479px) */
        @media (max-width: 479px) {
            .photo-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .header {
                padding: 1.25rem 0.75rem;
            }
            
            .header h1 {
                font-size: 1.75rem;
            }
            
            .container {
                padding: 1rem 0.75rem;
            }
            
            .btn {
                width: 180px;
                min-height: 52px;
                font-size: 1rem;
            }
        }

        /* Enhanced Touch-friendly controls for mobile devices */
        @media (hover: none) and (pointer: coarse) {
            /* Ensure all interactive elements meet minimum touch target size */
            .btn {
                min-height: 48px;
                min-width: 48px;
                padding: 14px 28px;
                touch-action: manipulation;
            }
            
            .photo-card {
                /* Remove hover effects on touch devices */
                transition: transform 0.2s ease;
                min-height: 48px;
                touch-action: manipulation;
            }
            
            .photo-card:hover {
                /* Reset hover effects for touch devices */
                transform: none;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            }
            
            .photo-card:active {
                transform: scale(0.98);
                transition: transform 0.1s ease;
            }
            
            /* Increase spacing for better touch interaction */
            .photo-grid {
                gap: 1.5rem;
            }
            
            /* Ensure adequate spacing between interactive elements */
            .header-buttons .btn {
                margin: 10px 8px;
            }
        }

        /* High DPI displays optimization */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .photo-card {
                border-width: 0.5px;
            }
        }

        /* Landscape orientation adjustments for mobile */
        @media (max-width: 767px) and (orientation: landscape) {
            .header {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 1.75rem;
            }
            
            .header p {
                font-size: 0.9rem;
                margin-bottom: 1rem;
            }
            
            .photo-grid {
                grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
                gap: 1rem;
            }
        }

        /* Photo Detail Modal Styles */
        .photo-detail-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            animation: fadeIn 0.3s ease-out;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        .photo-detail-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .photo-detail-content {
            background: white;
            border-radius: 16px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            position: relative;
            display: flex;
            flex-direction: column;
            animation: slideInUp 0.4s ease-out;
        }

        .photo-detail-header {
            padding: 1.5rem 2rem;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .photo-detail-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0;
        }

        .photo-detail-close {
            background: none;
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            width: 3rem;
            height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .photo-detail-close:hover {
            background-color: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .photo-detail-body {
            display: flex;
            flex: 1;
            min-height: 0;
        }

        .photo-detail-image-container {
            flex: 2;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f8f9fa;
            padding: 2rem;
            min-height: 400px;
        }

        .photo-detail-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
        }

        .photo-detail-info {
            flex: 1;
            padding: 2rem;
            background: white;
            overflow-y: auto;
            min-width: 300px;
        }

        .photo-detail-metadata {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .metadata-section {
            background: #f8f9fa;
            padding: 1.25rem;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .metadata-section h4 {
            margin: 0 0 1rem 0;
            color: #2c3e50;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .metadata-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #e9ecef;
        }

        .metadata-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .metadata-label {
            font-weight: 600;
            color: #495057;
            min-width: 80px;
            margin-right: 1rem;
        }

        .metadata-value {
            color: #6c757d;
            text-align: right;
            flex: 1;
            word-break: break-word;
        }

        .metadata-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .metadata-tag {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .metadata-description {
            background: #e3f2fd;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
            margin-top: 1rem;
            font-style: italic;
            color: #1565c0;
        }

        .metadata-missing {
            color: #6c757d;
            font-style: italic;
            opacity: 0.7;
        }

        /* Responsive modal design */
        @media (max-width: 768px) {
            .photo-detail-content {
                max-width: 95vw;
                max-height: 95vh;
                margin: 1rem;
            }

            .photo-detail-body {
                flex-direction: column;
            }

            .photo-detail-image-container {
                flex: none;
                min-height: 250px;
                padding: 1rem;
            }

            .photo-detail-info {
                min-width: auto;
                padding: 1.5rem;
            }

            .photo-detail-header {
                padding: 1rem 1.5rem;
            }

            .photo-detail-title {
                font-size: 1.25rem;
            }
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        /* Reduced motion preferences */
        @media (prefers-reduced-motion: reduce) {
            .photo-card,
            .btn,
            .loading-spinner,
            .step,
            .architecture-diagram,
            .photo-detail-modal,
            .photo-detail-content,
            .error,
            .success-message {
                transition: none !important;
                animation: none !important;
            }
            
            .photo-card:hover {
                transform: none;
            }

            .loading-dots div,
            .loading-progress-bar {
                animation: none !important;
            }
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            .photo-card {
                border: 2px solid;
            }
            
            .btn {
                border: 2px solid;
            }
            
            .step {
                border: 2px solid;
            }
        }

        /* Focus management and keyboard navigation */
        .focus-visible,
        *:focus-visible {
            outline: 3px solid #667eea;
            outline-offset: 2px;
            border-radius: 4px;
        }

        .photo-card:focus-visible {
            outline: 3px solid #667eea;
            outline-offset: 4px;
            transform: translateY(-4px);
        }

        .btn:focus-visible {
            outline: 3px solid #ffffff;
            outline-offset: 2px;
        }

        /* Skip link for keyboard navigation */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 6px;
            background: #667eea;
            color: white;
            padding: 8px;
            text-decoration: none;
            border-radius: 4px;
            z-index: 9999;
            font-weight: 600;
        }

        .skip-link:focus {
            top: 6px;
        }

        /* Lazy loading placeholder */
        .photo-card img[data-lazy] {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            min-height: 220px;
        }

        .photo-card img[data-lazy].loaded {
            animation: none;
            background: none;
        }

        /* Intersection observer loading state */
        .photo-card.lazy-loading {
            opacity: 0.7;
        }

        .photo-card.lazy-loaded {
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        /* Performance optimizations */
        .photo-grid {
            contain: layout style;
        }

        .photo-card {
            contain: layout style paint;
            will-change: transform;
        }

        .photo-card:hover {
            will-change: transform, box-shadow;
        }

        /* Screen reader only content */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Demo Mode Styles */
        .demo-banner {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
            padding: 12px 20px;
            text-align: center;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            animation: pulse-banner 2s ease-in-out infinite alternate;
        }

        @keyframes pulse-banner {
            from { opacity: 0.9; }
            to { opacity: 1; }
        }

        .demo-controls {
            background: rgba(0,0,0,0.85);
            color: white;
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 20px;
            border-radius: 16px;
            z-index: 1001;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            min-width: 200px;
        }

        .demo-controls h4 {
            margin: 0 0 15px 0;
            font-size: 1rem;
            color: #fff;
            text-align: center;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 10px;
        }

        .demo-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            margin: 4px 2px;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            width: calc(50% - 4px);
            display: inline-block;
        }

        .demo-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
        }

        .demo-btn.success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .demo-btn.warning {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
        }

        .demo-btn.danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .demo-status {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            font-size: 0.8rem;
            text-align: center;
        }

        /* Demo photo overlays */
        .demo-photo-overlay {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(255, 193, 7, 0.9);
            color: #212529;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            z-index: 10;
        }
    </style>
</head>
<body>
    <!-- Demo Banner -->
    <div class="demo-banner">
        üé≠ DEMO MODE: Family Photo Gallery - Full Feature Preview with High-Quality Mock Photos
    </div>

    <!-- Skip link for keyboard navigation -->
    <a href="#main-content" class="skip-link">Skip to main content</a>
    
    <!-- Gradient header with professional styling -->
    <header class="header" role="banner">
        <h1>Family Photo Gallery</h1>
        <p>Explore our family memories powered by AWS serverless architecture</p>
        <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; margin-top: 10px; font-size: 0.9rem;">
            <strong>üé≠ Demo Mode:</strong> This preview uses high-quality mock photos to demonstrate all features
        </div>
        
        <!-- SEE PHOTOS button and architecture toggle -->
        <div class="header-buttons" role="group" aria-label="Main actions">
            <button id="seePhotosBtn" class="btn btn-primary" 
                    aria-describedby="photos-description"
                    type="button">
                SEE PHOTOS
            </button>
            <span id="photos-description" class="sr-only">Load and display family photos from AWS S3 storage</span>
            
            <button id="toggleArchitectureBtn" class="btn" 
                    aria-describedby="architecture-description"
                    aria-expanded="false"
                    aria-controls="architectureDiagram"
                    type="button">
                Show Architecture
            </button>
            <span id="architecture-description" class="sr-only">Toggle AWS serverless architecture visualization</span>
        </div>
    </header>

    <!-- Main container -->
    <main id="main-content" class="container" role="main">
        <!-- Architecture toggle section -->
        <section class="architecture-section" aria-labelledby="architecture-heading">
            <div id="architectureDiagram" class="architecture-diagram" 
                 role="region" 
                 aria-labelledby="architecture-heading"
                 aria-hidden="true">
                <h3 id="architecture-heading">AWS Serverless Architecture Flow</h3>
                <p>Real-time visualization of the serverless request flow from browser to S3</p>
                
                <div class="flow-container">
                    <div class="flow-header">
                        <div class="flow-title">Request Flow Status</div>
                        <div id="flowTiming" class="flow-timing" aria-live="polite">Ready to start</div>
                    </div>
                    
                    <div class="flow-steps" role="group" aria-label="AWS serverless architecture steps">
                        <div class="step" id="step-0" 
                             role="status" 
                             aria-label="Browser Request step"
                             tabindex="0">
                            <div class="step-title">1. Browser Request</div>
                            <div class="step-status" id="step-0-status" aria-live="polite">Ready</div>
                            <div class="step-timing" id="step-0-timing" aria-live="polite">-</div>
                            <div class="step-progress" aria-hidden="true"></div>
                        </div>
                        <div class="step" id="step-1" 
                             role="status" 
                             aria-label="API Gateway step"
                             tabindex="0">
                            <div class="step-title">2. API Gateway</div>
                            <div class="step-status" id="step-1-status" aria-live="polite">Waiting</div>
                            <div class="step-timing" id="step-1-timing" aria-live="polite">-</div>
                            <div class="step-progress" aria-hidden="true"></div>
                        </div>
                        <div class="step" id="step-2" 
                             role="status" 
                             aria-label="Lambda Function step"
                             tabindex="0">
                            <div class="step-title">3. Lambda Function</div>
                            <div class="step-status" id="step-2-status" aria-live="polite">Waiting</div>
                            <div class="step-timing" id="step-2-timing" aria-live="polite">-</div>
                            <div class="step-progress" aria-hidden="true"></div>
                        </div>
                        <div class="step" id="step-3" 
                             role="status" 
                             aria-label="S3 Bucket Access step"
                             tabindex="0">
                            <div class="step-title">4. S3 Bucket Access</div>
                            <div class="step-status" id="step-3-status" aria-live="polite">Waiting</div>
                            <div class="step-timing" id="step-3-timing" aria-live="polite">-</div>
                            <div class="step-progress" aria-hidden="true"></div>
                        </div>
                        <div class="step" id="step-4" 
                             role="status" 
                             aria-label="Response Processing step"
                             tabindex="0">
                            <div class="step-title">5. Response Processing</div>
                            <div class="step-status" id="step-4-status" aria-live="polite">Waiting</div>
                            <div class="step-timing" id="step-4-timing" aria-live="polite">-</div>
                            <div class="step-progress" aria-hidden="true"></div>
                        </div>
                    </div>
                    
                    <div class="flow-metrics" role="group" aria-label="Performance metrics">
                        <div class="metric" id="metric-total-time" role="status" aria-label="Total request time">
                            <div class="metric-value" id="total-time-value" aria-live="polite">-</div>
                            <div class="metric-label">Total Time</div>
                        </div>
                        <div class="metric" id="metric-request-count" role="status" aria-label="Number of requests made">
                            <div class="metric-value" id="request-count-value" aria-live="polite">0</div>
                            <div class="metric-label">Requests</div>
                        </div>
                        <div class="metric" id="metric-success-rate" role="status" aria-label="Success rate percentage">
                            <div class="metric-value" id="success-rate-value" aria-live="polite">-</div>
                            <div class="metric-label">Success Rate</div>
                        </div>
                        <div class="metric" id="metric-avg-time" role="status" aria-label="Average request time">
                            <div class="metric-value" id="avg-time-value" aria-live="polite">-</div>
                            <div class="metric-label">Avg Time</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Enhanced Loading state with spinner -->
        <div id="loadingState" class="loading" style="display: none;" 
             role="status" 
             aria-live="polite" 
             aria-label="Loading photos">
            <div class="loading-spinner" aria-hidden="true"></div>
            <div class="loading-progress" aria-hidden="true">
                <div class="loading-progress-bar"></div>
            </div>
            <div class="loading-text animated">Loading photos</div>
            <div id="loadingStatus" class="loading-status" 
                 style="font-size: 0.9rem; color: #6c757d; margin-top: 0.5rem;"
                 aria-live="polite">
                Connecting to AWS services...
            </div>
        </div>

        <!-- Enhanced Error state -->
        <div id="errorState" class="error" style="display: none;" 
             role="alert" 
             aria-live="assertive"
             aria-labelledby="error-heading">
            <div class="error-icon" aria-hidden="true">‚ö†Ô∏è</div>
            <h2 id="error-heading" class="sr-only">Error occurred</h2>
            <div id="errorMessage" class="error-message">Error loading photos. Please try again.</div>
            <div id="errorDetails" class="error-details" style="display: none;"></div>
            <div class="error-actions" role="group" aria-label="Error recovery actions">
                <button id="retryBtn" class="retry-btn" 
                        type="button"
                        aria-describedby="retry-description">
                    Retry
                </button>
                <span id="retry-description" class="sr-only">Retry loading photos from AWS services</span>
                
                <button id="diagnosticsBtn" class="diagnostics-btn" 
                        style="margin-left: 0.5rem;"
                        type="button"
                        aria-describedby="diagnostics-description">
                    üîç Diagnostics
                </button>
                <span id="diagnostics-description" class="sr-only">Open diagnostic panel to troubleshoot issues</span>
            </div>
        </div>

        <!-- Diagnostic Panel Modal -->
        <div id="diagnosticPanel" class="diagnostic-panel" style="display: none;">
            <div class="diagnostic-content">
                <div class="diagnostic-header">
                    <h3>üîç Error Diagnostics & Support</h3>
                    <button id="diagnosticClose" class="diagnostic-close">√ó</button>
                </div>
                <div class="diagnostic-body">
                    <div class="diagnostic-section">
                        <h4>üìä System Status</h4>
                        <div id="diagnosticSystemStatus" class="diagnostic-info">
                            Checking system status...
                        </div>
                    </div>
                    
                    <div class="diagnostic-section">
                        <h4>üåê Network Connectivity</h4>
                        <div id="diagnosticNetworkStatus" class="diagnostic-info">
                            Testing network connectivity...
                        </div>
                    </div>
                    
                    <div class="diagnostic-section">
                        <h4>üìà Error Summary</h4>
                        <div id="diagnosticErrorSummary" class="diagnostic-info">
                            Loading error summary...
                        </div>
                    </div>
                    
                    <div class="diagnostic-section">
                        <h4>üí° Recommended Actions</h4>
                        <div id="diagnosticRecommendations" class="diagnostic-info">
                            Generating recommendations...
                        </div>
                    </div>
                    
                    <div class="diagnostic-actions">
                        <button id="exportDiagnosticsBtn" class="diagnostic-action-btn">üìÑ Export Report</button>
                        <button id="clearErrorLogBtn" class="diagnostic-action-btn">üóëÔ∏è Clear Error Log</button>
                        <button id="testConnectivityBtn" class="diagnostic-action-btn">üîÑ Test Connectivity</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Success message -->
        <div id="successMessage" class="success-message" style="display: none;" 
             role="status" 
             aria-live="polite"
             aria-labelledby="success-heading">
            <div style="font-size: 1.5rem; margin-bottom: 0.5rem;" aria-hidden="true">‚úÖ</div>
            <h2 id="success-heading" class="sr-only">Success</h2>
            <div id="successText">Photos loaded successfully!</div>
        </div>

        <!-- Responsive CSS Grid container for photos -->
        <section id="photoGrid" class="photo-grid" 
                 role="region" 
                 aria-label="Family photo gallery"
                 aria-live="polite">
            <!-- Photos will be dynamically inserted here -->
        </section>
    </main>

    <!-- Photo Detail Modal -->
    <div id="photoDetailModal" class="photo-detail-modal">
        <div class="photo-detail-content">
            <div class="photo-detail-header">
                <h2 id="photoDetailTitle" class="photo-detail-title">Photo Details</h2>
                <button id="photoDetailClose" class="photo-detail-close" aria-label="Close photo details">√ó</button>
            </div>
            <div class="photo-detail-body">
                <div class="photo-detail-image-container">
                    <img id="photoDetailImage" class="photo-detail-image" src="" alt="" />
                </div>
                <div class="photo-detail-info">
                    <div id="photoDetailMetadata" class="photo-detail-metadata">
                        <!-- Metadata will be dynamically inserted here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Demo Controls -->
    <div class="demo-controls">
        <h4>üéÆ Demo Controls</h4>
        <button class="demo-btn success" onclick="simulatePhotoLoad()">üì∏ Load Photos</button>
        <button class="demo-btn" onclick="simulateArchitecture()">üèóÔ∏è Architecture</button>
        <button class="demo-btn warning" onclick="simulateError()">‚ö†Ô∏è Test Error</button>
        <button class="demo-btn danger" onclick="simulateLoading()">‚è≥ Loading</button>
        <button class="demo-btn" onclick="resetDemo()">üîÑ Reset</button>
        <button class="demo-btn" onclick="showPhotoDetails()">üîç Photo Detail</button>
        <div class="demo-status" id="demoStatus">Ready for demo</div>
    </div>

    <script>
        // ============================================================================
        // CONFIGURATION
        // ============================================================================
        // 
        // To connect to your AWS API Gateway:
        // 1. Replace 'your-api-gateway-id' in the baseUrl below with your actual API Gateway ID
        // 2. Ensure your API Gateway has CORS enabled for your domain
        // 3. Verify the Lambda function has the BUCKET_NAME environment variable set to 'family-bucket-22'
        // 4. Confirm the S3 bucket 'family-bucket-22' exists and contains photos in the /uploads folder
        //
        // Example: https://abc123def4.execute-api.us-east-2.amazonaws.com
        // ============================================================================

        // Photo Model Class with comprehensive metadata handling
        class Photo {
            constructor(url, key, lastModified, size, metadata = {}) {
                this.url = url;
                this.key = key;
                this.lastModified = new Date(lastModified);
                this.size = size;
                this.metadata = metadata;
            }
            
            // Get display name with fallback handling
            getDisplayName() {
                if (this.metadata.title && this.metadata.title.trim()) {
                    return this.metadata.title.trim();
                }
                
                // Extract filename from key, handling various path formats
                const filename = this.key.split('/').pop();
                if (filename) {
                    // Remove file extension and format nicely
                    return filename.replace(/\.[^/.]+$/, "").replace(/[-_]/g, ' ');
                }
                
                return 'Untitled Photo';
            }
            
            // Format file size with proper units
            getFormattedSize() {
                return this.formatBytes(this.size);
            }
            
            // Format date with locale-aware formatting
            getFormattedDate() {
                if (!this.lastModified || isNaN(this.lastModified.getTime())) {
                    return 'Unknown Date';
                }
                return this.lastModified.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });
            }
            
            // Get description with fallback
            getDescription() {
                return this.metadata.description || '';
            }
            
            // Get tags as array
            getTags() {
                if (Array.isArray(this.metadata.tags)) {
                    return this.metadata.tags;
                }
                if (typeof this.metadata.tags === 'string') {
                    return this.metadata.tags.split(',').map(tag => tag.trim()).filter(tag => tag);
                }
                return [];
            }
            
            // Check if photo has complete metadata
            hasCompleteMetadata() {
                return !!(this.metadata.title && this.metadata.description);
            }
            
            // Get metadata summary for display
            getMetadataSummary() {
                const summary = {
                    name: this.getDisplayName(),
                    date: this.getFormattedDate(),
                    size: this.getFormattedSize(),
                    description: this.getDescription(),
                    tags: this.getTags()
                };
                
                return summary;
            }
            
            // Validate photo data
            isValid() {
                return !!(this.url && this.key && this.size >= 0);
            }
            
            // Private helper method for formatting bytes
            formatBytes(bytes) {
                if (bytes === 0) return '0 Bytes';
                if (bytes < 0) return 'Unknown Size';
                
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                
                if (i >= sizes.length) return 'Very Large';
                
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
        }

        // Application State Management with comprehensive state tracking
        const AppState = {
            // Photo data
            photos: [],
            
            // UI states
            loading: false,
            error: null,
            showArchitecture: false,
            
            // API interaction states
            apiStatus: {
                browser: 'idle',        // idle, requesting, complete, error
                apiGateway: 'idle',     // idle, processing, complete, error
                lambda: 'idle',         // idle, executing, complete, error
                s3: 'idle'              // idle, accessing, complete, error
            },
            
            // Request tracking
            currentRequest: null,
            requestStartTime: null,
            requestEndTime: null,
            
            // Error details
            errorDetails: {
                type: null,             // network, api, timeout, cors, etc.
                message: null,
                code: null,
                timestamp: null
            },
            
            // UI preferences
            preferences: {
                gridDensity: 'normal',  // dense, normal, spacious
                showMetadata: true,
                animationsEnabled: true
            }
        };

        // Architecture Flow State for visualization tracking
        const FlowState = {
            steps: [
                { 
                    name: 'Browser Request', 
                    status: 'idle',        // idle, active, complete, error
                    timestamp: null,
                    duration: null,
                    details: null,
                    startTime: null
                },
                { 
                    name: 'API Gateway', 
                    status: 'idle', 
                    timestamp: null,
                    duration: null,
                    details: null,
                    startTime: null
                },
                { 
                    name: 'Lambda Function', 
                    status: 'idle', 
                    timestamp: null,
                    duration: null,
                    details: null,
                    startTime: null
                },
                { 
                    name: 'S3 Bucket Access', 
                    status: 'idle', 
                    timestamp: null,
                    duration: null,
                    details: null,
                    startTime: null
                },
                { 
                    name: 'Response Processing', 
                    status: 'idle', 
                    timestamp: null,
                    duration: null,
                    details: null,
                    startTime: null
                }
            ],
            
            // Overall flow tracking
            flowStartTime: null,
            flowEndTime: null,
            totalDuration: null,
            isActive: false,
            
            // Metrics tracking
            metrics: {
                totalRequests: 0,
                successfulRequests: 0,
                failedRequests: 0,
                totalTime: 0,
                averageTime: 0,
                successRate: 0,
                requestHistory: []
            }
        };

        // State update functions and event handling
        const StateManager = {
            // Photo state management
            setPhotos(photos) {
                AppState.photos = photos.map(photoData => {
                    if (photoData instanceof Photo) {
                        return photoData;
                    }
                    return new Photo(
                        photoData.url,
                        photoData.key,
                        photoData.lastModified,
                        photoData.size,
                        photoData.metadata
                    );
                }).filter(photo => photo.isValid());
                
                this.notifyStateChange('photos', AppState.photos);
            },
            
            addPhoto(photoData) {
                const photo = photoData instanceof Photo ? photoData : new Photo(
                    photoData.url,
                    photoData.key,
                    photoData.lastModified,
                    photoData.size,
                    photoData.metadata
                );
                
                if (photo.isValid()) {
                    AppState.photos.push(photo);
                    this.notifyStateChange('photoAdded', photo);
                }
            },
            
            // Loading state management
            setLoading(isLoading) {
                AppState.loading = isLoading;
                this.notifyStateChange('loading', isLoading);
            },
            
            // Error state management
            setError(error, type = 'general') {
                AppState.error = error;
                AppState.errorDetails = {
                    type: type,
                    message: error,
                    code: null,
                    timestamp: new Date()
                };
                this.notifyStateChange('error', AppState.errorDetails);
            },
            
            clearError() {
                AppState.error = null;
                AppState.errorDetails = {
                    type: null,
                    message: null,
                    code: null,
                    timestamp: null
                };
                this.notifyStateChange('errorCleared', null);
            },
            
            // Architecture visibility
            setArchitectureVisibility(visible) {
                AppState.showArchitecture = visible;
                this.notifyStateChange('architectureVisibility', visible);
            },
            
            // API status management
            setApiStatus(component, status, details = null) {
                if (AppState.apiStatus.hasOwnProperty(component)) {
                    AppState.apiStatus[component] = status;
                    this.notifyStateChange('apiStatus', { component, status, details });
                }
            },
            
            // Flow state management
            startFlow() {
                FlowState.isActive = true;
                FlowState.flowStartTime = new Date();
                FlowState.flowEndTime = null;
                FlowState.totalDuration = null;
                
                // Reset all steps
                FlowState.steps.forEach(step => {
                    step.status = 'idle';
                    step.timestamp = null;
                    step.duration = null;
                    step.details = null;
                });
                
                this.notifyStateChange('flowStarted', FlowState);
            },
            
            updateFlowStep(stepIndex, status, details = null) {
                if (stepIndex >= 0 && stepIndex < FlowState.steps.length) {
                    const step = FlowState.steps[stepIndex];
                    const previousStatus = step.status;
                    
                    step.status = status;
                    step.details = details;
                    
                    if (status === 'active' && previousStatus !== 'active') {
                        step.startTime = new Date();
                        step.timestamp = step.startTime;
                    } else if ((status === 'complete' || status === 'error') && step.startTime) {
                        step.duration = new Date() - step.startTime;
                    }
                    
                    this.notifyStateChange('flowStepUpdated', { stepIndex, step, previousStatus });
                }
            },
            
            completeFlow(success = true) {
                FlowState.isActive = false;
                FlowState.flowEndTime = new Date();
                if (FlowState.flowStartTime) {
                    FlowState.totalDuration = FlowState.flowEndTime - FlowState.flowStartTime;
                }
                
                // Update metrics
                FlowState.metrics.totalRequests++;
                if (success) {
                    FlowState.metrics.successfulRequests++;
                } else {
                    FlowState.metrics.failedRequests++;
                }
                
                // Calculate success rate
                FlowState.metrics.successRate = Math.round(
                    (FlowState.metrics.successfulRequests / FlowState.metrics.totalRequests) * 100
                );
                
                // Update average time
                if (FlowState.totalDuration) {
                    FlowState.metrics.totalTime += FlowState.totalDuration;
                    FlowState.metrics.averageTime = Math.round(
                        FlowState.metrics.totalTime / FlowState.metrics.totalRequests
                    );
                    
                    // Add to request history (keep last 10)
                    FlowState.metrics.requestHistory.push({
                        timestamp: FlowState.flowEndTime,
                        duration: FlowState.totalDuration,
                        success: success
                    });
                    
                    if (FlowState.metrics.requestHistory.length > 10) {
                        FlowState.metrics.requestHistory.shift();
                    }
                }
                
                this.notifyStateChange('flowCompleted', { flowState: FlowState, success });
            },
            
            // Request tracking
            startRequest(requestId) {
                AppState.currentRequest = requestId;
                AppState.requestStartTime = new Date();
                AppState.requestEndTime = null;
                this.notifyStateChange('requestStarted', requestId);
            },
            
            completeRequest() {
                AppState.requestEndTime = new Date();
                this.notifyStateChange('requestCompleted', {
                    requestId: AppState.currentRequest,
                    duration: AppState.requestEndTime - AppState.requestStartTime
                });
            },
            
            // Event system for state changes
            listeners: new Map(),
            
            addEventListener(event, callback) {
                if (!this.listeners.has(event)) {
                    this.listeners.set(event, []);
                }
                this.listeners.get(event).push(callback);
            },
            
            removeEventListener(event, callback) {
                if (this.listeners.has(event)) {
                    const callbacks = this.listeners.get(event);
                    const index = callbacks.indexOf(callback);
                    if (index > -1) {
                        callbacks.splice(index, 1);
                    }
                }
            },
            
            notifyStateChange(event, data) {
                if (this.listeners.has(event)) {
                    this.listeners.get(event).forEach(callback => {
                        try {
                            callback(data);
                        } catch (error) {
                            console.error('Error in state change listener:', error);
                        }
                    });
                }
                
                // Also trigger generic state change event
                if (event !== 'stateChanged') {
                    this.notifyStateChange('stateChanged', { event, data });
                }
            },
            
            // Utility methods
            getState() {
                return {
                    app: { ...AppState },
                    flow: { ...FlowState }
                };
            },
            
            resetState() {
                // Reset app state
                AppState.photos = [];
                AppState.loading = false;
                AppState.error = null;
                AppState.showArchitecture = false;
                AppState.currentRequest = null;
                AppState.requestStartTime = null;
                AppState.requestEndTime = null;
                
                // Reset API status
                Object.keys(AppState.apiStatus).forEach(key => {
                    AppState.apiStatus[key] = 'idle';
                });
                
                // Reset error details
                AppState.errorDetails = {
                    type: null,
                    message: null,
                    code: null,
                    timestamp: null
                };
                
                // Reset flow state
                FlowState.steps.forEach(step => {
                    step.status = 'idle';
                    step.timestamp = null;
                    step.duration = null;
                    step.details = null;
                    step.startTime = null;
                });
                
                FlowState.flowStartTime = null;
                FlowState.flowEndTime = null;
                FlowState.totalDuration = null;
                FlowState.isActive = false;
                
                // Reset metrics (but keep history for learning)
                // Only reset counters, not the accumulated history
                FlowState.metrics.totalRequests = 0;
                FlowState.metrics.successfulRequests = 0;
                FlowState.metrics.failedRequests = 0;
                FlowState.metrics.totalTime = 0;
                FlowState.metrics.averageTime = 0;
                FlowState.metrics.successRate = 0;
                FlowState.metrics.requestHistory = [];
                
                this.notifyStateChange('stateReset', null);
            }
        };

        // DOM Elements
        const seePhotosBtn = document.getElementById('seePhotosBtn');
        const toggleArchitectureBtn = document.getElementById('toggleArchitectureBtn');
        const architectureDiagram = document.getElementById('architectureDiagram');
        const loadingState = document.getElementById('loadingState');
        const errorState = document.getElementById('errorState');
        const photoGrid = document.getElementById('photoGrid');
        const retryBtn = document.getElementById('retryBtn');
        const photoDetailModal = document.getElementById('photoDetailModal');
        const photoDetailClose = document.getElementById('photoDetailClose');
        const photoDetailTitle = document.getElementById('photoDetailTitle');
        const photoDetailImage = document.getElementById('photoDetailImage');
        const photoDetailMetadata = document.getElementById('photoDetailMetadata');

        // DOM Elements for diagnostics
        const diagnosticsBtn = document.getElementById('diagnosticsBtn');
        const diagnosticPanel = document.getElementById('diagnosticPanel');
        const diagnosticClose = document.getElementById('diagnosticClose');
        const exportDiagnosticsBtn = document.getElementById('exportDiagnosticsBtn');
        const clearErrorLogBtn = document.getElementById('clearErrorLogBtn');
        const testConnectivityBtn = document.getElementById('testConnectivityBtn');

        // Event Listeners with enhanced keyboard support
        seePhotosBtn.addEventListener('click', handleSeePhotos);
        seePhotosBtn.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                handleSeePhotos();
            }
        });
        
        toggleArchitectureBtn.addEventListener('click', toggleArchitecture);
        toggleArchitectureBtn.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                toggleArchitecture();
            }
        });
        
        retryBtn.addEventListener('click', handleRetry);
        retryBtn.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                handleRetry();
            }
        });
        
        photoDetailClose.addEventListener('click', closePhotoDetail);
        photoDetailClose.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                closePhotoDetail();
            }
        });
        
        diagnosticsBtn.addEventListener('click', showDiagnosticPanel);
        diagnosticsBtn.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                showDiagnosticPanel();
            }
        });
        
        diagnosticClose.addEventListener('click', closeDiagnosticPanel);
        diagnosticClose.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                closeDiagnosticPanel();
            }
        });
        
        exportDiagnosticsBtn.addEventListener('click', exportDiagnostics);
        clearErrorLogBtn.addEventListener('click', clearErrorLog);
        testConnectivityBtn.addEventListener('click', testConnectivity);
        
        // Close modal when clicking outside the content
        photoDetailModal.addEventListener('click', (e) => {
            if (e.target === photoDetailModal) {
                closePhotoDetail();
            }
        });
        
        // Enhanced keyboard navigation for modals and global shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (photoDetailModal.classList.contains('show')) {
                    closePhotoDetail();
                } else if (diagnosticPanel.style.display === 'flex') {
                    closeDiagnosticPanel();
                }
            }
        });
        
        // Close diagnostic panel when clicking outside
        diagnosticPanel.addEventListener('click', (e) => {
            if (e.target === diagnosticPanel) {
                closeDiagnosticPanel();
            }
        });

        // Toggle Architecture Diagram
        function toggleArchitecture() {
            const newVisibility = !AppState.showArchitecture;
            StateManager.setArchitectureVisibility(newVisibility);
            
            if (newVisibility) {
                architectureDiagram.classList.add('show');
                architectureDiagram.setAttribute('aria-hidden', 'false');
                toggleArchitectureBtn.textContent = 'Hide Architecture';
                toggleArchitectureBtn.setAttribute('aria-expanded', 'true');
                
                // Initialize visualization state
                resetArchitectureVisualization();
                updateMetricsDisplay();
                
                // If flow is currently active, start updates
                if (FlowState.isActive) {
                    startMetricsUpdates();
                }
                
                // Announce to screen readers
                announceToScreenReader('Architecture diagram is now visible');
            } else {
                architectureDiagram.classList.remove('show');
                architectureDiagram.setAttribute('aria-hidden', 'true');
                toggleArchitectureBtn.textContent = 'Show Architecture';
                toggleArchitectureBtn.setAttribute('aria-expanded', 'false');
                
                // Stop updates when hidden
                stopMetricsUpdates();
                
                // Announce to screen readers
                announceToScreenReader('Architecture diagram is now hidden');
            }
        }

        // Photo Detail Modal Functions
        function showPhotoDetail(photo) {
            const metadata = photo.getMetadataSummary();
            
            // Set modal title
            photoDetailTitle.textContent = metadata.name;
            
            // Show loading state for image
            photoDetailImage.style.opacity = '0.5';
            photoDetailImage.style.filter = 'blur(2px)';
            
            // Set modal image with loading handling
            photoDetailImage.onload = () => {
                photoDetailImage.style.opacity = '1';
                photoDetailImage.style.filter = 'none';
                photoDetailImage.style.transition = 'opacity 0.3s ease, filter 0.3s ease';
                announceToScreenReader('Photo image loaded successfully');
            };
            
            photoDetailImage.onerror = () => {
                photoDetailImage.style.opacity = '1';
                photoDetailImage.style.filter = 'none';
                photoDetailImage.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cmVjdCB3aWR0aD0iNDAwIiBoZWlnaHQ9IjMwMCIgZmlsbD0iI2Y4ZjlmYSIvPgogIDx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwsIHNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTgiIGZpbGw9IiM2Yzc1N2QiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj7wn5O3IEltYWdlIG5vdCBhdmFpbGFibGU8L3RleHQ+Cjwvc3ZnPg==';
                announceToScreenReader('Photo image failed to load');
            };
            
            photoDetailImage.src = photo.url;
            photoDetailImage.alt = `Full size view of ${metadata.name}. ${metadata.description || 'No description available.'}`;
            
            // Generate detailed metadata display
            renderPhotoDetailMetadata(photo, metadata);
            
            // Show modal with animation
            photoDetailModal.classList.add('show');
            photoDetailModal.setAttribute('aria-hidden', 'false');
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
            
            // Store the previously focused element
            photoDetailModal.dataset.previousFocus = document.activeElement.id || 'body';
            
            // Focus management for accessibility - focus close button
            setTimeout(() => {
                photoDetailClose.focus();
            }, 100);
            
            // Set up modal keyboard navigation
            setupModalKeyboardNavigation();
            
            // Announce to screen readers
            announceToScreenReader(`Photo details opened for ${metadata.name}`);
            
            console.log('Photo detail modal opened for:', metadata.name);
        }

        function closePhotoDetail() {
            photoDetailModal.classList.remove('show');
            photoDetailModal.setAttribute('aria-hidden', 'true');
            document.body.style.overflow = ''; // Restore scrolling
            
            // Restore focus to previously focused element
            const previousFocusId = photoDetailModal.dataset.previousFocus;
            if (previousFocusId && previousFocusId !== 'body') {
                const previousElement = document.getElementById(previousFocusId);
                if (previousElement) {
                    previousElement.focus();
                } else {
                    // Fallback to first photo card
                    focusFirstPhoto();
                }
            } else {
                // Fallback to first photo card
                focusFirstPhoto();
            }
            
            // Clear image source to free memory
            setTimeout(() => {
                if (!photoDetailModal.classList.contains('show')) {
                    photoDetailImage.src = '';
                    photoDetailMetadata.innerHTML = '';
                }
            }, 300);
            
            // Announce to screen readers
            announceToScreenReader('Photo details closed');
            
            console.log('Photo detail modal closed');
        }

        // Modal keyboard navigation
        function setupModalKeyboardNavigation() {
            const focusableElements = photoDetailModal.querySelectorAll(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            
            const firstFocusable = focusableElements[0];
            const lastFocusable = focusableElements[focusableElements.length - 1];
            
            // Trap focus within modal
            photoDetailModal.addEventListener('keydown', function trapFocus(e) {
                if (e.key === 'Tab') {
                    if (e.shiftKey) {
                        // Shift + Tab
                        if (document.activeElement === firstFocusable) {
                            e.preventDefault();
                            lastFocusable.focus();
                        }
                    } else {
                        // Tab
                        if (document.activeElement === lastFocusable) {
                            e.preventDefault();
                            firstFocusable.focus();
                        }
                    }
                }
            });
        }

        function renderPhotoDetailMetadata(photo, metadata) {
            const hasDescription = metadata.description && metadata.description.trim();
            const hasTags = metadata.tags && metadata.tags.length > 0;
            const hasCompleteMetadata = photo.hasCompleteMetadata();
            
            // Build metadata sections
            let metadataHTML = '';
            
            // Basic Information Section
            metadataHTML += `
                <div class="metadata-section">
                    <h4>üìã Basic Information</h4>
                    <div class="metadata-item">
                        <span class="metadata-label">Name:</span>
                        <span class="metadata-value">${metadata.name}</span>
                    </div>
                    <div class="metadata-item">
                        <span class="metadata-label">Date:</span>
                        <span class="metadata-value">${metadata.date}</span>
                    </div>
                    <div class="metadata-item">
                        <span class="metadata-label">Size:</span>
                        <span class="metadata-value">${metadata.size}</span>
                    </div>
                    <div class="metadata-item">
                        <span class="metadata-label">Key:</span>
                        <span class="metadata-value">${photo.key}</span>
                    </div>
                </div>
            `;
            
            // Description Section (if available)
            if (hasDescription) {
                metadataHTML += `
                    <div class="metadata-section">
                        <h4>üìù Description</h4>
                        <div class="metadata-description">
                            ${metadata.description}
                        </div>
                    </div>
                `;
            } else {
                metadataHTML += `
                    <div class="metadata-section">
                        <h4>üìù Description</h4>
                        <div class="metadata-missing">No description available</div>
                    </div>
                `;
            }
            
            // Tags Section (if available)
            if (hasTags) {
                const tagsHTML = metadata.tags.map(tag => 
                    `<span class="metadata-tag">${tag}</span>`
                ).join('');
                
                metadataHTML += `
                    <div class="metadata-section">
                        <h4>üè∑Ô∏è Tags</h4>
                        <div class="metadata-tags">
                            ${tagsHTML}
                        </div>
                    </div>
                `;
            } else {
                metadataHTML += `
                    <div class="metadata-section">
                        <h4>üè∑Ô∏è Tags</h4>
                        <div class="metadata-missing">No tags available</div>
                    </div>
                `;
            }
            
            // Technical Details Section
            metadataHTML += `
                <div class="metadata-section">
                    <h4>üîß Technical Details</h4>
                    <div class="metadata-item">
                        <span class="metadata-label">URL:</span>
                        <span class="metadata-value" style="word-break: break-all; font-size: 0.8rem;">
                            ${photo.url.length > 50 ? photo.url.substring(0, 50) + '...' : photo.url}
                        </span>
                    </div>
                    <div class="metadata-item">
                        <span class="metadata-label">Valid:</span>
                        <span class="metadata-value">${photo.isValid() ? '‚úÖ Yes' : '‚ùå No'}</span>
                    </div>
                    <div class="metadata-item">
                        <span class="metadata-label">Complete Metadata:</span>
                        <span class="metadata-value">${hasCompleteMetadata ? '‚úÖ Yes' : '‚ö†Ô∏è Partial'}</span>
                    </div>
                </div>
            `;
            
            // Metadata Quality Indicator
            const qualityScore = calculateMetadataQuality(photo);
            const qualityColor = qualityScore >= 80 ? '#28a745' : qualityScore >= 50 ? '#ffc107' : '#dc3545';
            const qualityText = qualityScore >= 80 ? 'Excellent' : qualityScore >= 50 ? 'Good' : 'Basic';
            
            metadataHTML += `
                <div class="metadata-section">
                    <h4>üìä Metadata Quality</h4>
                    <div class="metadata-item">
                        <span class="metadata-label">Score:</span>
                        <span class="metadata-value" style="color: ${qualityColor}; font-weight: 600;">
                            ${qualityScore}% (${qualityText})
                        </span>
                    </div>
                </div>
            `;
            
            photoDetailMetadata.innerHTML = metadataHTML;
        }

        // Calculate metadata quality score for display
        function calculateMetadataQuality(photo) {
            let score = 0;
            const metadata = photo.metadata;
            
            // Basic requirements (40 points)
            if (photo.url) score += 10;
            if (photo.key) score += 10;
            if (photo.lastModified && !isNaN(photo.lastModified.getTime())) score += 10;
            if (photo.size >= 0) score += 10;
            
            // Enhanced metadata (60 points)
            if (metadata.title && metadata.title.trim()) score += 20;
            if (metadata.description && metadata.description.trim()) score += 20;
            if (metadata.tags && (Array.isArray(metadata.tags) ? metadata.tags.length > 0 : metadata.tags.trim())) score += 20;
            
            return Math.min(100, score);
        }

        // AWS API Configuration (Demo Mode - Uses Mock Data)
        const API_CONFIG = {
            // AWS API Gateway endpoint in us-east-2 region (Demo uses mock data instead)
            baseUrl: 'DEMO_MODE_MOCK_API',
            endpoints: {
                photos: '/photos'
            },
            timeout: 30000, // 30 seconds timeout
            retryAttempts: 3,
            retryDelay: 1000 // 1 second initial delay
        };

        // AWS API Service for handling all API interactions
        class AWSApiService {
            constructor(config) {
                this.config = config;
                this.abortController = null;
            }

            // Create fetch service for calling GET /photos endpoint
            async fetchPhotos() {
                const requestId = 'fetch-photos-' + Date.now();
                
                try {
                    // Start request tracking
                    StateManager.startRequest(requestId);
                    StateManager.startFlow();
                    StateManager.updateFlowStep(0, 'active', 'Initiating photo request');
                    updateLoadingStatus('Preparing request...');

                    // Create abort controller for timeout management
                    this.abortController = new AbortController();
                    const timeoutId = setTimeout(() => {
                        this.abortController.abort();
                    }, this.config.timeout);

                    // Construct API URL
                    const apiUrl = `${this.config.baseUrl}${this.config.endpoints.photos}`;
                    
                    StateManager.updateFlowStep(0, 'complete', 'Request sent successfully');
                    StateManager.updateFlowStep(1, 'active', 'Processing through API Gateway');
                    updateLoadingStatus('Connecting to API Gateway...');

                    // Make fetch request with CORS handling and timeout management
                    const response = await fetch(apiUrl, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json',
                            'Cache-Control': 'no-cache', // Ensure fresh data
                            // CORS headers are handled by the browser and API Gateway
                        },
                        mode: 'cors', // Enable CORS
                        credentials: 'omit', // Don't send credentials for security
                        cache: 'no-cache', // Don't cache API responses
                        signal: this.abortController.signal
                    });

                    // Clear timeout since request completed
                    clearTimeout(timeoutId);

                    StateManager.updateFlowStep(1, 'complete', 'API Gateway processed request');
                    StateManager.updateFlowStep(2, 'active', 'Lambda function executing');
                    updateLoadingStatus('Lambda function processing...');

                    // Handle HTTP error responses
                    if (!response.ok) {
                        const errorData = await this.parseErrorResponse(response);
                        throw new APIError(
                            `API request failed: ${response.status} ${response.statusText}`,
                            'api_error',
                            response.status,
                            errorData
                        );
                    }

                    StateManager.updateFlowStep(2, 'complete', 'Lambda function completed');
                    StateManager.updateFlowStep(3, 'active', 'Accessing S3 bucket');
                    updateLoadingStatus('Retrieving photos from S3...');

                    // Parse and validate response
                    const data = await this.parseResponse(response);
                    
                    StateManager.updateFlowStep(3, 'complete', 'S3 data retrieved');
                    StateManager.updateFlowStep(4, 'active', 'Processing response');
                    updateLoadingStatus('Processing photo data...');

                    // Validate response format
                    const validatedData = this.validatePhotosResponse(data);
                    
                    StateManager.updateFlowStep(4, 'complete', 'Response processed successfully');
                    StateManager.completeFlow(true); // Success
                    StateManager.completeRequest();
                    updateLoadingStatus('Photos ready!');

                    return validatedData;

                } catch (error) {
                    // Handle different types of errors
                    this.handleApiError(error);
                    throw error;
                } finally {
                    // Clean up abort controller
                    if (this.abortController) {
                        this.abortController = null;
                    }
                }
            }

            // Parse JSON response with error handling
            async parseResponse(response) {
                try {
                    const text = await response.text();
                    if (!text) {
                        throw new APIError('Empty response from server', 'parse_error');
                    }
                    return JSON.parse(text);
                } catch (error) {
                    if (error instanceof APIError) {
                        throw error;
                    }
                    throw new APIError(
                        'Failed to parse response as JSON',
                        'parse_error',
                        null,
                        { originalError: error.message }
                    );
                }
            }

            // Parse error response for better error messages
            async parseErrorResponse(response) {
                try {
                    const text = await response.text();
                    return text ? JSON.parse(text) : null;
                } catch (error) {
                    return null;
                }
            }

            // Validate photos response format according to API contract
            validatePhotosResponse(data) {
                if (!data || typeof data !== 'object') {
                    throw new APIError('Invalid response format: expected object', 'validation_error');
                }

                if (!Array.isArray(data.photos)) {
                    throw new APIError('Invalid response format: photos must be an array', 'validation_error');
                }

                // Validate each photo object
                const validatedPhotos = data.photos.map((photo, index) => {
                    if (!photo || typeof photo !== 'object') {
                        throw new APIError(`Invalid photo at index ${index}: expected object`, 'validation_error');
                    }

                    // Required fields
                    if (!photo.url || typeof photo.url !== 'string') {
                        throw new APIError(`Invalid photo at index ${index}: url is required and must be a string`, 'validation_error');
                    }

                    if (!photo.key || typeof photo.key !== 'string') {
                        throw new APIError(`Invalid photo at index ${index}: key is required and must be a string`, 'validation_error');
                    }

                    if (!photo.lastModified || typeof photo.lastModified !== 'string') {
                        throw new APIError(`Invalid photo at index ${index}: lastModified is required and must be a string`, 'validation_error');
                    }

                    if (typeof photo.size !== 'number' || photo.size < 0) {
                        throw new APIError(`Invalid photo at index ${index}: size must be a non-negative number`, 'validation_error');
                    }

                    // Validate date format
                    const date = new Date(photo.lastModified);
                    if (isNaN(date.getTime())) {
                        throw new APIError(`Invalid photo at index ${index}: lastModified must be a valid ISO date string`, 'validation_error');
                    }

                    // Validate URL format
                    try {
                        new URL(photo.url);
                    } catch (error) {
                        throw new APIError(`Invalid photo at index ${index}: url must be a valid URL`, 'validation_error');
                    }

                    // Optional metadata validation
                    if (photo.metadata && typeof photo.metadata !== 'object') {
                        throw new APIError(`Invalid photo at index ${index}: metadata must be an object if provided`, 'validation_error');
                    }

                    return {
                        url: photo.url,
                        key: photo.key,
                        lastModified: photo.lastModified,
                        size: photo.size,
                        metadata: photo.metadata || {}
                    };
                });

                return { photos: validatedPhotos };
            }

            // Handle different types of API errors
            // Enhanced comprehensive error handling with detailed recovery options
            handleApiError(error) {
                let errorType = 'general';
                let errorMessage = 'An unexpected error occurred';
                let stepIndex = 1; // Default to API Gateway step
                let recoveryActions = [];
                let technicalDetails = null;

                if (error.name === 'AbortError') {
                    errorType = 'timeout';
                    errorMessage = 'Request timed out after 30 seconds. The server may be experiencing high load.';
                    stepIndex = 1; // Could be any step
                    recoveryActions = [
                        'Check your internet connection',
                        'Try again in a few moments',
                        'Contact support if the issue persists'
                    ];
                    technicalDetails = 'The request was automatically cancelled due to timeout. This may indicate network issues or server overload.';
                    StateManager.updateFlowStep(stepIndex, 'error', 'Request timed out after 30 seconds');
                } else if (error instanceof APIError) {
                    errorType = error.type;
                    errorMessage = error.message;
                    technicalDetails = error.details ? JSON.stringify(error.details) : null;
                    
                    // Enhanced error mapping with specific recovery actions
                    switch (error.type) {
                        case 'api_error':
                            if (error.code === 400) {
                                stepIndex = 1; // API Gateway
                                errorMessage = 'Bad request. The API request format is invalid.';
                                recoveryActions = [
                                    'This is likely a configuration issue',
                                    'Contact the administrator',
                                    'Check API Gateway request format'
                                ];
                            } else if (error.code === 401) {
                                stepIndex = 1; // API Gateway
                                errorMessage = 'Unauthorized access. Authentication is required.';
                                recoveryActions = [
                                    'Check API Gateway authentication settings',
                                    'Verify API keys or tokens',
                                    'Contact administrator for access'
                                ];
                            } else if (error.code === 403) {
                                stepIndex = 1; // API Gateway
                                errorMessage = 'Access forbidden. Check API Gateway permissions and CORS configuration.';
                                recoveryActions = [
                                    'Verify CORS settings in API Gateway',
                                    'Check resource permissions',
                                    'Contact administrator for access'
                                ];
                            } else if (error.code === 404) {
                                stepIndex = 1; // API Gateway
                                errorMessage = 'API endpoint not found. The requested resource does not exist.';
                                recoveryActions = [
                                    'Verify the API Gateway URL is correct',
                                    'Check the endpoint path (/photos)',
                                    'Ensure the API Gateway is deployed'
                                ];
                            } else if (error.code === 429) {
                                stepIndex = 1; // API Gateway
                                errorMessage = 'Too many requests. Rate limit exceeded.';
                                recoveryActions = [
                                    'Wait a few minutes before retrying',
                                    'Check API Gateway throttling settings',
                                    'Contact administrator about rate limits'
                                ];
                            } else if (error.code === 500) {
                                stepIndex = 2; // Lambda
                                errorMessage = 'Internal server error. The Lambda function encountered an issue.';
                                recoveryActions = [
                                    'Try again in a few moments',
                                    'Check Lambda function logs',
                                    'Verify Lambda function configuration'
                                ];
                            } else if (error.code === 502) {
                                stepIndex = 1; // API Gateway
                                errorMessage = 'Bad Gateway. API Gateway cannot reach the Lambda function.';
                                recoveryActions = [
                                    'Check Lambda function status',
                                    'Verify API Gateway integration',
                                    'Try again in a few moments'
                                ];
                            } else if (error.code === 503) {
                                stepIndex = 1; // API Gateway
                                errorMessage = 'Service unavailable. The API is temporarily down.';
                                recoveryActions = [
                                    'Try again in a few minutes',
                                    'Check AWS service status',
                                    'Contact administrator if issue persists'
                                ];
                            } else if (error.code === 504) {
                                stepIndex = 2; // Lambda timeout
                                errorMessage = 'Gateway timeout. The Lambda function took too long to respond.';
                                recoveryActions = [
                                    'Try again with a smaller request',
                                    'Check Lambda function timeout settings',
                                    'Verify S3 bucket accessibility'
                                ];
                            } else {
                                stepIndex = 1; // API Gateway
                                errorMessage = `API error (${error.code}): ${error.message}`;
                                recoveryActions = [
                                    'Try again in a few moments',
                                    'Check API Gateway status',
                                    'Contact support if issue persists'
                                ];
                            }
                            break;
                            
                        case 'lambda_error':
                            stepIndex = 2; // Lambda
                            recoveryActions = [
                                'Check Lambda function logs in CloudWatch',
                                'Verify BUCKET_NAME environment variable',
                                'Ensure Lambda has S3 permissions'
                            ];
                            break;
                            
                        case 's3_error':
                            stepIndex = 3; // S3
                            recoveryActions = [
                                'Verify S3 bucket "family-bucket-22" exists',
                                'Check S3 bucket permissions',
                                'Ensure photos exist in /uploads folder'
                            ];
                            break;
                            
                        case 'validation_error':
                            stepIndex = 4; // Response Processing
                            recoveryActions = [
                                'This indicates invalid data from the server',
                                'Check API response format',
                                'Contact administrator about data integrity'
                            ];
                            break;
                            
                        case 'parse_error':
                            stepIndex = 4; // Response Processing
                            errorMessage = 'Invalid response format. The server returned malformed data.';
                            recoveryActions = [
                                'The server response is not valid JSON',
                                'Check API Gateway response mapping',
                                'Verify Lambda function return format'
                            ];
                            break;
                            
                        default:
                            stepIndex = 1; // API Gateway
                            recoveryActions = [
                                'Try refreshing the page',
                                'Check your internet connection',
                                'Contact support if issue persists'
                            ];
                    }
                    
                    StateManager.updateFlowStep(stepIndex, 'error', error.message);
                } else if (error.name === 'TypeError') {
                    if (error.message.includes('fetch') || error.message.includes('Failed to fetch')) {
                        errorType = 'network';
                        errorMessage = 'Network connection failed. Unable to reach the server.';
                        stepIndex = 0; // Browser Request
                        recoveryActions = [
                            'Check your internet connection',
                            'Verify you can access other websites',
                            'Try disabling VPN or proxy if using one',
                            'Check firewall settings'
                        ];
                        technicalDetails = 'Network request failed at the browser level. This could indicate connectivity issues, DNS problems, or firewall blocking.';
                        StateManager.updateFlowStep(stepIndex, 'error', 'Network connection failed');
                    } else if (error.message.includes('CORS') || error.message.includes('cross-origin')) {
                        errorType = 'cors';
                        errorMessage = 'Cross-origin request blocked. The API Gateway CORS configuration needs updating.';
                        stepIndex = 1; // API Gateway
                        recoveryActions = [
                            'Enable CORS in API Gateway for this domain',
                            'Add proper Access-Control headers',
                            'Contact administrator to fix CORS settings'
                        ];
                        technicalDetails = 'Browser blocked the request due to CORS policy. The API Gateway needs to allow requests from this origin.';
                        StateManager.updateFlowStep(stepIndex, 'error', 'CORS policy blocked request');
                    } else {
                        errorType = 'network';
                        errorMessage = 'Connection error. Unable to establish connection to the server.';
                        stepIndex = 0; // Browser Request
                        recoveryActions = [
                            'Check your internet connection',
                            'Try refreshing the page',
                            'Verify the API Gateway URL is correct'
                        ];
                        technicalDetails = `JavaScript TypeError: ${error.message}`;
                        StateManager.updateFlowStep(stepIndex, 'error', 'Connection failed');
                    }
                } else if (error.name === 'SyntaxError') {
                    errorType = 'parse_error';
                    errorMessage = 'Invalid response format. The server returned malformed JSON data.';
                    stepIndex = 4; // Response Processing
                    recoveryActions = [
                        'The server response is not valid JSON',
                        'Check Lambda function return format',
                        'Verify API Gateway response mapping'
                    ];
                    technicalDetails = `JSON parsing failed: ${error.message}`;
                    StateManager.updateFlowStep(stepIndex, 'error', 'Response parsing failed');
                } else {
                    console.error('Unexpected API error:', error);
                    errorMessage = `Unexpected error: ${error.message || 'Unknown error occurred'}`;
                    recoveryActions = [
                        'Try refreshing the page',
                        'Clear browser cache and cookies',
                        'Contact support with error details'
                    ];
                    technicalDetails = `Unexpected error type: ${error.name}, Message: ${error.message}, Stack: ${error.stack}`;
                    StateManager.updateFlowStep(stepIndex, 'error', 'Unexpected error occurred');
                }

                // Enhanced error state with recovery actions and technical details
                StateManager.setError(errorMessage, errorType);
                AppState.errorDetails.recoveryActions = recoveryActions;
                AppState.errorDetails.technicalDetails = technicalDetails;
                AppState.errorDetails.stepIndex = stepIndex;
                
                // Log error for monitoring and analysis
                const errorId = errorMonitor.logError(error, {
                    source: 'api',
                    errorType: errorType,
                    stepIndex: stepIndex,
                    recoveryActions: recoveryActions,
                    apiConfig: API_CONFIG
                });
                AppState.errorDetails.errorId = errorId;
                
                StateManager.completeFlow(false); // Failure
                StateManager.completeRequest();
            }

            // Retry mechanism for failed requests
            async fetchPhotosWithRetry(maxRetries = null) {
                const retries = maxRetries || this.config.retryAttempts;
                let lastError = null;

                for (let attempt = 1; attempt <= retries; attempt++) {
                    try {
                        console.log(`Attempting to fetch photos (attempt ${attempt}/${retries})`);
                        return await this.fetchPhotos();
                    } catch (error) {
                        lastError = error;
                        
                        // Don't retry on certain error types
                        if (error instanceof APIError && 
                            (error.type === 'validation_error' || error.type === 'cors' || error.code === 404)) {
                            throw error;
                        }

                        // Don't retry on the last attempt
                        if (attempt === retries) {
                            throw error;
                        }

                        // Wait before retrying with exponential backoff
                        const delay = this.config.retryDelay * Math.pow(2, attempt - 1);
                        console.log(`Retrying in ${delay}ms...`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }

                throw lastError;
            }

            // Cancel ongoing request
            cancelRequest() {
                if (this.abortController) {
                    this.abortController.abort();
                    this.abortController = null;
                }
            }
        }

        // Custom API Error class for better error handling
        class APIError extends Error {
            constructor(message, type = 'general', code = null, details = null) {
                super(message);
                this.name = 'APIError';
                this.type = type;
                this.code = code;
                this.details = details;
                this.timestamp = new Date();
            }
        }

        // Development environment detection
        function isDevelopmentEnvironment() {
            return location.hostname === 'localhost' || 
                   location.hostname === '127.0.0.1' || 
                   location.protocol === 'file:';
        }

        // Check if API is configured
        function isApiConfigured() {
            return !API_CONFIG.baseUrl.includes('your-api-gateway-id');
        }

        // Enhanced network connectivity checker
        async function checkNetworkConnectivity() {
            const connectivityTests = [
                // Test 1: Basic internet connectivity
                {
                    name: 'Internet Connection',
                    test: () => fetch('https://www.google.com/favicon.ico', { 
                        method: 'HEAD', 
                        mode: 'no-cors',
                        cache: 'no-cache',
                        signal: AbortSignal.timeout(5000)
                    })
                },
                // Test 2: DNS resolution
                {
                    name: 'DNS Resolution',
                    test: () => fetch('https://1.1.1.1/', { 
                        method: 'HEAD', 
                        mode: 'no-cors',
                        cache: 'no-cache',
                        signal: AbortSignal.timeout(3000)
                    })
                },
                // Test 3: AWS services connectivity (if configured)
                {
                    name: 'AWS Connectivity',
                    test: () => {
                        if (!isApiConfigured()) return Promise.resolve();
                        return fetch('https://aws.amazon.com/favicon.ico', { 
                            method: 'HEAD', 
                            mode: 'no-cors',
                            cache: 'no-cache',
                            signal: AbortSignal.timeout(5000)
                        });
                    }
                }
            ];

            const results = {
                overall: true,
                tests: {},
                recommendations: []
            };

            for (const test of connectivityTests) {
                try {
                    await test.test();
                    results.tests[test.name] = { success: true, error: null };
                    console.log(`‚úì ${test.name}: OK`);
                } catch (error) {
                    results.tests[test.name] = { success: false, error: error.message };
                    results.overall = false;
                    console.log(`‚úó ${test.name}: ${error.message}`);
                    
                    // Add specific recommendations based on failed tests
                    switch (test.name) {
                        case 'Internet Connection':
                            results.recommendations.push('Check your internet connection');
                            results.recommendations.push('Verify network cables or WiFi connection');
                            break;
                        case 'DNS Resolution':
                            results.recommendations.push('DNS resolution issues detected');
                            results.recommendations.push('Try using a different DNS server (8.8.8.8)');
                            break;
                        case 'AWS Connectivity':
                            results.recommendations.push('AWS services may be unreachable');
                            results.recommendations.push('Check AWS service status page');
                            break;
                    }
                }
            }

            return results;
        }

        // Enhanced error recovery system
        class ErrorRecoverySystem {
            constructor() {
                this.recoveryStrategies = new Map();
                this.setupRecoveryStrategies();
            }

            setupRecoveryStrategies() {
                // Network error recovery
                this.recoveryStrategies.set('network', {
                    autoRetry: true,
                    maxRetries: 3,
                    retryDelay: 2000,
                    preRetryCheck: () => checkNetworkConnectivity(),
                    recoveryActions: [
                        'Check internet connection',
                        'Disable VPN if active',
                        'Try a different network',
                        'Contact network administrator'
                    ]
                });

                // Timeout error recovery
                this.recoveryStrategies.set('timeout', {
                    autoRetry: true,
                    maxRetries: 2,
                    retryDelay: 5000,
                    recoveryActions: [
                        'Server may be overloaded',
                        'Try again in a few minutes',
                        'Check AWS service status'
                    ]
                });

                // CORS error recovery
                this.recoveryStrategies.set('cors', {
                    autoRetry: false,
                    maxRetries: 1,
                    retryDelay: 1000,
                    recoveryActions: [
                        'CORS configuration issue detected',
                        'Contact administrator to enable CORS',
                        'This requires server-side configuration'
                    ]
                });

                // API Gateway error recovery
                this.recoveryStrategies.set('api_error', {
                    autoRetry: true,
                    maxRetries: 2,
                    retryDelay: 3000,
                    recoveryActions: [
                        'API Gateway error detected',
                        'Check API Gateway status',
                        'Verify endpoint configuration'
                    ]
                });

                // Lambda error recovery
                this.recoveryStrategies.set('lambda_error', {
                    autoRetry: true,
                    maxRetries: 1,
                    retryDelay: 5000,
                    recoveryActions: [
                        'Lambda function error',
                        'Check CloudWatch logs',
                        'Verify function configuration'
                    ]
                });

                // S3 error recovery
                this.recoveryStrategies.set('s3_error', {
                    autoRetry: true,
                    maxRetries: 2,
                    retryDelay: 2000,
                    recoveryActions: [
                        'S3 bucket access error',
                        'Check bucket permissions',
                        'Verify bucket exists'
                    ]
                });
            }

            async attemptRecovery(errorType, currentAttempt = 0) {
                const strategy = this.recoveryStrategies.get(errorType);
                if (!strategy) {
                    console.log('No recovery strategy for error type:', errorType);
                    return false;
                }

                if (currentAttempt >= strategy.maxRetries) {
                    console.log('Max recovery attempts reached for:', errorType);
                    return false;
                }

                console.log(`Attempting recovery for ${errorType}, attempt ${currentAttempt + 1}/${strategy.maxRetries}`);

                // Run pre-retry check if available
                if (strategy.preRetryCheck) {
                    try {
                        const checkResult = await strategy.preRetryCheck();
                        if (!checkResult.overall) {
                            console.log('Pre-retry check failed:', checkResult);
                            return false;
                        }
                    } catch (error) {
                        console.log('Pre-retry check error:', error);
                        return false;
                    }
                }

                // Wait for retry delay
                await new Promise(resolve => setTimeout(resolve, strategy.retryDelay));

                return true;
            }

            getRecoveryActions(errorType) {
                const strategy = this.recoveryStrategies.get(errorType);
                return strategy ? strategy.recoveryActions : [
                    'Try refreshing the page',
                    'Check your internet connection',
                    'Contact support if issue persists'
                ];
            }

            shouldAutoRetry(errorType) {
                const strategy = this.recoveryStrategies.get(errorType);
                return strategy ? strategy.autoRetry : false;
            }
        }

        // Initialize error recovery system
        const errorRecoverySystem = new ErrorRecoverySystem();

        // Comprehensive error monitoring and reporting system
        class ErrorMonitoringSystem {
            constructor() {
                this.errorLog = [];
                this.maxLogEntries = 50;
                this.errorPatterns = new Map();
                this.setupErrorPatterns();
            }

            setupErrorPatterns() {
                // Common error patterns and their likely causes
                this.errorPatterns.set(/Failed to fetch/i, {
                    type: 'network',
                    cause: 'Network connectivity issue',
                    severity: 'high'
                });

                this.errorPatterns.set(/CORS/i, {
                    type: 'cors',
                    cause: 'Cross-origin request blocked',
                    severity: 'high'
                });

                this.errorPatterns.set(/timeout/i, {
                    type: 'timeout',
                    cause: 'Request timeout',
                    severity: 'medium'
                });

                this.errorPatterns.set(/404|not found/i, {
                    type: 'api_error',
                    cause: 'Resource not found',
                    severity: 'high'
                });

                this.errorPatterns.set(/500|internal server error/i, {
                    type: 'lambda_error',
                    cause: 'Server internal error',
                    severity: 'high'
                });

                this.errorPatterns.set(/502|bad gateway/i, {
                    type: 'api_error',
                    cause: 'Gateway error',
                    severity: 'high'
                });

                this.errorPatterns.set(/503|service unavailable/i, {
                    type: 'api_error',
                    cause: 'Service temporarily unavailable',
                    severity: 'medium'
                });
            }

            logError(error, context = {}) {
                const errorEntry = {
                    timestamp: new Date(),
                    message: error.message || error.toString(),
                    type: error.type || 'unknown',
                    code: error.code || null,
                    stack: error.stack || null,
                    context: context,
                    pattern: this.analyzeErrorPattern(error.message || error.toString()),
                    userAgent: navigator.userAgent,
                    url: window.location.href,
                    id: this.generateErrorId()
                };

                this.errorLog.push(errorEntry);

                // Keep log size manageable
                if (this.errorLog.length > this.maxLogEntries) {
                    this.errorLog.shift();
                }

                console.group(`üö® Error Logged [${errorEntry.id}]`);
                console.error('Error:', errorEntry.message);
                console.log('Type:', errorEntry.type);
                console.log('Context:', errorEntry.context);
                console.log('Pattern Analysis:', errorEntry.pattern);
                console.groupEnd();

                return errorEntry.id;
            }

            analyzeErrorPattern(errorMessage) {
                for (const [pattern, info] of this.errorPatterns) {
                    if (pattern.test(errorMessage)) {
                        return info;
                    }
                }
                return { type: 'unknown', cause: 'Unrecognized error pattern', severity: 'low' };
            }

            generateErrorId() {
                return 'ERR_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 5);
            }

            getErrorSummary() {
                const summary = {
                    totalErrors: this.errorLog.length,
                    errorsByType: {},
                    errorsBySeverity: { high: 0, medium: 0, low: 0 },
                    recentErrors: this.errorLog.slice(-5),
                    commonPatterns: {}
                };

                this.errorLog.forEach(entry => {
                    // Count by type
                    summary.errorsByType[entry.type] = (summary.errorsByType[entry.type] || 0) + 1;
                    
                    // Count by severity
                    const severity = entry.pattern.severity || 'low';
                    summary.errorsBySeverity[severity]++;
                    
                    // Count common patterns
                    const patternKey = entry.pattern.cause || 'Unknown';
                    summary.commonPatterns[patternKey] = (summary.commonPatterns[patternKey] || 0) + 1;
                });

                return summary;
            }

            exportErrorLog() {
                const exportData = {
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    url: window.location.href,
                    summary: this.getErrorSummary(),
                    errors: this.errorLog
                };

                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `family-photo-gallery-errors-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log('Error log exported successfully');
            }

            clearErrorLog() {
                this.errorLog = [];
                console.log('Error log cleared');
            }

            // Get diagnostic information for support
            getDiagnosticInfo() {
                return {
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    url: window.location.href,
                    screen: {
                        width: screen.width,
                        height: screen.height,
                        colorDepth: screen.colorDepth
                    },
                    viewport: {
                        width: window.innerWidth,
                        height: window.innerHeight
                    },
                    connection: navigator.connection ? {
                        effectiveType: navigator.connection.effectiveType,
                        downlink: navigator.connection.downlink,
                        rtt: navigator.connection.rtt
                    } : 'Not available',
                    apiConfig: {
                        baseUrl: API_CONFIG.baseUrl,
                        configured: isApiConfigured(),
                        timeout: API_CONFIG.timeout
                    },
                    errorSummary: this.getErrorSummary(),
                    appState: {
                        photosLoaded: AppState.photos.length,
                        loading: AppState.loading,
                        hasError: !!AppState.error,
                        showArchitecture: AppState.showArchitecture
                    }
                };
            }
        }

        // Initialize error monitoring system
        const errorMonitor = new ErrorMonitoringSystem();

        // Diagnostic Panel Functions
        async function showDiagnosticPanel() {
            console.log('Opening diagnostic panel');
            diagnosticPanel.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            
            // Load diagnostic information
            await loadDiagnosticInfo();
            
            // Focus close button for accessibility
            diagnosticClose.focus();
        }

        function closeDiagnosticPanel() {
            diagnosticPanel.style.display = 'none';
            document.body.style.overflow = '';
            console.log('Diagnostic panel closed');
        }

        async function loadDiagnosticInfo() {
            // Load system status
            const systemStatusEl = document.getElementById('diagnosticSystemStatus');
            systemStatusEl.innerHTML = 'Loading system information...';
            
            try {
                const diagnosticInfo = errorMonitor.getDiagnosticInfo();
                
                // System Status
                let systemStatusHTML = '';
                systemStatusHTML += `<div class="diagnostic-status-item">
                    <span class="diagnostic-status-label">Browser:</span>
                    <span class="diagnostic-status-value">${navigator.userAgent.split(' ')[0]}</span>
                </div>`;
                systemStatusHTML += `<div class="diagnostic-status-item">
                    <span class="diagnostic-status-label">Screen Resolution:</span>
                    <span class="diagnostic-status-value">${diagnosticInfo.screen.width}x${diagnosticInfo.screen.height}</span>
                </div>`;
                systemStatusHTML += `<div class="diagnostic-status-item">
                    <span class="diagnostic-status-label">Viewport:</span>
                    <span class="diagnostic-status-value">${diagnosticInfo.viewport.width}x${diagnosticInfo.viewport.height}</span>
                </div>`;
                systemStatusHTML += `<div class="diagnostic-status-item">
                    <span class="diagnostic-status-label">API Configured:</span>
                    <span class="diagnostic-status-value ${diagnosticInfo.apiConfig.configured ? 'diagnostic-status-ok' : 'diagnostic-status-error'}">
                        ${diagnosticInfo.apiConfig.configured ? '‚úì Yes' : '‚úó No'}
                    </span>
                </div>`;
                systemStatusHTML += `<div class="diagnostic-status-item">
                    <span class="diagnostic-status-label">Photos Loaded:</span>
                    <span class="diagnostic-status-value">${diagnosticInfo.appState.photosLoaded}</span>
                </div>`;
                
                systemStatusEl.innerHTML = systemStatusHTML;
                
                // Network Status
                const networkStatusEl = document.getElementById('diagnosticNetworkStatus');
                networkStatusEl.innerHTML = 'Testing network connectivity...';
                
                try {
                    const connectivityResult = await checkNetworkConnectivity();
                    let networkHTML = '';
                    
                    networkHTML += `<div class="diagnostic-status-item">
                        <span class="diagnostic-status-label">Overall Status:</span>
                        <span class="diagnostic-status-value ${connectivityResult.overall ? 'diagnostic-status-ok' : 'diagnostic-status-error'}">
                            ${connectivityResult.overall ? '‚úì Connected' : '‚úó Issues Detected'}
                        </span>
                    </div>`;
                    
                    Object.entries(connectivityResult.tests).forEach(([testName, result]) => {
                        networkHTML += `<div class="diagnostic-status-item">
                            <span class="diagnostic-status-label">${testName}:</span>
                            <span class="diagnostic-status-value ${result.success ? 'diagnostic-status-ok' : 'diagnostic-status-error'}">
                                ${result.success ? '‚úì OK' : '‚úó Failed'}
                            </span>
                        </div>`;
                    });
                    
                    if (connectivityResult.recommendations.length > 0) {
                        networkHTML += '<div style="margin-top: 1rem;"><strong>Recommendations:</strong><ul>';
                        connectivityResult.recommendations.forEach(rec => {
                            networkHTML += `<li>${rec}</li>`;
                        });
                        networkHTML += '</ul></div>';
                    }
                    
                    networkStatusEl.innerHTML = networkHTML;
                } catch (error) {
                    networkStatusEl.innerHTML = `<span class="diagnostic-status-error">Network test failed: ${error.message}</span>`;
                }
                
                // Error Summary
                const errorSummaryEl = document.getElementById('diagnosticErrorSummary');
                const errorSummary = diagnosticInfo.errorSummary;
                
                let errorHTML = '';
                errorHTML += `<div class="diagnostic-status-item">
                    <span class="diagnostic-status-label">Total Errors:</span>
                    <span class="diagnostic-status-value">${errorSummary.totalErrors}</span>
                </div>`;
                
                if (errorSummary.totalErrors > 0) {
                    errorHTML += '<div style="margin-top: 1rem;"><strong>Errors by Type:</strong><ul>';
                    Object.entries(errorSummary.errorsByType).forEach(([type, count]) => {
                        errorHTML += `<li>${type}: ${count}</li>`;
                    });
                    errorHTML += '</ul></div>';
                    
                    errorHTML += '<div style="margin-top: 1rem;"><strong>Recent Errors:</strong><ul>';
                    errorSummary.recentErrors.forEach(error => {
                        errorHTML += `<li>${error.timestamp.toLocaleTimeString()}: ${error.message}</li>`;
                    });
                    errorHTML += '</ul></div>';
                } else {
                    errorHTML += '<div style="margin-top: 1rem; color: #28a745;">No errors recorded in this session.</div>';
                }
                
                errorSummaryEl.innerHTML = errorHTML;
                
                // Recommendations
                const recommendationsEl = document.getElementById('diagnosticRecommendations');
                const recommendations = generateRecommendations(diagnosticInfo);
                
                let recHTML = '<ul>';
                recommendations.forEach(rec => {
                    recHTML += `<li>${rec}</li>`;
                });
                recHTML += '</ul>';
                
                recommendationsEl.innerHTML = recHTML;
                
            } catch (error) {
                console.error('Failed to load diagnostic info:', error);
                systemStatusEl.innerHTML = `<span class="diagnostic-status-error">Failed to load diagnostic information: ${error.message}</span>`;
            }
        }

        function generateRecommendations(diagnosticInfo) {
            const recommendations = [];
            
            // API Configuration
            if (!diagnosticInfo.apiConfig.configured) {
                recommendations.push('Configure the API Gateway URL in the configuration section');
                recommendations.push('Update the baseUrl in API_CONFIG to point to your AWS API Gateway');
            }
            
            // Error-based recommendations
            if (diagnosticInfo.errorSummary.totalErrors > 0) {
                const errorsByType = diagnosticInfo.errorSummary.errorsByType;
                
                if (errorsByType.network) {
                    recommendations.push('Network errors detected - check your internet connection');
                    recommendations.push('Try disabling VPN or proxy if active');
                }
                
                if (errorsByType.cors) {
                    recommendations.push('CORS errors detected - enable CORS in your API Gateway');
                    recommendations.push('Add proper Access-Control headers to your API responses');
                }
                
                if (errorsByType.timeout) {
                    recommendations.push('Timeout errors detected - check server performance');
                    recommendations.push('Consider increasing the timeout value in API_CONFIG');
                }
                
                if (errorsByType.api_error) {
                    recommendations.push('API errors detected - check your API Gateway and Lambda function');
                    recommendations.push('Verify the API endpoint URL and deployment status');
                }
            }
            
            // Connection-based recommendations
            if (diagnosticInfo.connection && diagnosticInfo.connection !== 'Not available') {
                if (diagnosticInfo.connection.effectiveType === 'slow-2g' || diagnosticInfo.connection.effectiveType === '2g') {
                    recommendations.push('Slow network detected - consider optimizing for low bandwidth');
                }
            }
            
            // Default recommendations
            if (recommendations.length === 0) {
                recommendations.push('System appears to be functioning normally');
                recommendations.push('If you continue to experience issues, try refreshing the page');
                recommendations.push('Contact support if problems persist');
            }
            
            return recommendations;
        }

        async function exportDiagnostics() {
            try {
                errorMonitor.exportErrorLog();
                console.log('Diagnostics exported successfully');
            } catch (error) {
                console.error('Failed to export diagnostics:', error);
                alert('Failed to export diagnostics: ' + error.message);
            }
        }

        function clearErrorLog() {
            if (confirm('Are you sure you want to clear the error log? This action cannot be undone.')) {
                errorMonitor.clearErrorLog();
                loadDiagnosticInfo(); // Refresh the display
                console.log('Error log cleared by user');
            }
        }

        async function testConnectivity() {
            const testBtn = testConnectivityBtn;
            const originalText = testBtn.textContent;
            
            testBtn.textContent = 'üîÑ Testing...';
            testBtn.disabled = true;
            
            try {
                await loadDiagnosticInfo(); // This will run the connectivity tests
                console.log('Connectivity test completed');
            } catch (error) {
                console.error('Connectivity test failed:', error);
            } finally {
                testBtn.textContent = originalText;
                testBtn.disabled = false;
            }
        }

        // Enhanced global error handler
        window.addEventListener('error', (event) => {
            errorMonitor.logError(event.error || new Error(event.message), {
                source: 'global',
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno
            });
        });

        window.addEventListener('unhandledrejection', (event) => {
            errorMonitor.logError(event.reason || new Error('Unhandled promise rejection'), {
                source: 'promise',
                promise: event.promise
            });
        });

        // Initialize API service
        const apiService = new AWSApiService(API_CONFIG);

        // Handle See Photos Button Click (Demo Mode)
        async function handleSeePhotos() {
            console.log('üé≠ Demo: See Photos button clicked - using demo photos');
            
            // In demo mode, always use mock data
            simulatePhotoLoad();
            return;
            
            // Check if API is configured
            if (!isApiConfigured()) {
                const message = isDevelopmentEnvironment() 
                    ? 'API not configured. Please update the API Gateway URL in the configuration section. Showing placeholder photos for development.'
                    : 'API configuration required. Please contact the administrator.';
                
                StateManager.setError(message, 'configuration');
                
                if (isDevelopmentEnvironment()) {
                    console.warn('API not configured, showing placeholder photos for development');
                    setTimeout(() => {
                        showPlaceholderPhotos();
                    }, 1000);
                }
                return;
            }
            
            // Clear any previous errors and feedback
            StateManager.clearError();
            clearAllFeedback();
            
            // Start enhanced loading state
            StateManager.setLoading(true);
            showLoading('Initializing photo request...');
            
            try {
                // Fetch photos from AWS API with retry mechanism
                const data = await apiService.fetchPhotosWithRetry();
                
                // Update state with fetched photos
                StateManager.setPhotos(data.photos);
                
                // Show success message
                showSuccess('Photos loaded successfully!', data.photos.length);
                
                // Render photos in the UI
                renderPhotos();
                
                console.log(`Successfully loaded ${data.photos.length} photos from AWS API`);
                
            } catch (error) {
                console.error('Failed to fetch photos:', error);
                
                // Enhanced error handling with details
                let errorDetails = null;
                if (error instanceof APIError && error.details) {
                    errorDetails = `Error Code: ${error.code || 'Unknown'} | Type: ${error.type}`;
                }
                
                // Show enhanced error state (error handling is already done in the API service)
                // Just ensure loading state is cleared
                StateManager.setLoading(false);
                
                // Show fallback placeholder photos for development/testing in certain scenarios
                if (isDevelopmentEnvironment() && (error.type === 'network' || error.type === 'timeout' || error.type === 'cors')) {
                    console.log('Development environment: showing placeholder photos due to API issues');
                    
                    // Show a development notice
                    showError(
                        'Development Mode: API connection failed, showing placeholder photos in 3 seconds...',
                        'network',
                        'This is normal in development. Placeholder photos will load automatically.'
                    );
                    
                    setTimeout(() => {
                        StateManager.clearError();
                        clearAllFeedback();
                        showPlaceholderPhotos();
                        showSuccess('Placeholder photos loaded for development', 6);
                    }, 3000);
                }
            } finally {
                // Always clear loading state
                StateManager.setLoading(false);
            }
        }

        // Enhanced Loading State Management with performance optimizations
        function showLoading(statusText = 'Connecting to AWS services...') {
            // Use requestAnimationFrame for smooth DOM updates
            requestAnimationFrame(() => {
                // Hide other states efficiently
                const elementsToHide = [errorState, document.getElementById('successMessage')];
                elementsToHide.forEach(el => {
                    if (el) el.style.display = 'none';
                });
                
                // Clear photo grid efficiently
                while (photoGrid.firstChild) {
                    photoGrid.removeChild(photoGrid.firstChild);
                }
                
                // Show loading state with animation
                loadingState.style.display = 'block';
                
                // Update loading status text
                const loadingStatus = document.getElementById('loadingStatus');
                if (loadingStatus && loadingStatus.textContent !== statusText) {
                    loadingStatus.textContent = statusText;
                }
                
                // Add loading animation to the container
                if (!loadingState.style.animation) {
                    loadingState.style.animation = 'fadeInUp 0.3s ease-out';
                }
            });
        }

        function hideLoading() {
            loadingState.style.display = 'none';
        }

        // Update loading status during API calls
        function updateLoadingStatus(status) {
            const loadingStatus = document.getElementById('loadingStatus');
            if (loadingStatus && loadingState.style.display !== 'none') {
                loadingStatus.textContent = status;
            }
        }

        // Enhanced Error State Management
        // Enhanced Error State Management with comprehensive recovery guidance
        function showError(message, type = 'general', details = null) {
            StateManager.setError(message, type);
            
            // Hide other states
            loadingState.style.display = 'none';
            document.getElementById('successMessage').style.display = 'none';
            
            // Show error state
            errorState.style.display = 'block';
            
            // Update error message
            const errorMessageEl = document.getElementById('errorMessage');
            if (errorMessageEl) {
                errorMessageEl.textContent = message;
            }
            
            // Enhanced error details with recovery actions and technical information
            const errorDetailsEl = document.getElementById('errorDetails');
            if (errorDetailsEl) {
                let detailsHTML = '';
                
                // Show recovery actions if available
                if (AppState.errorDetails.recoveryActions && AppState.errorDetails.recoveryActions.length > 0) {
                    detailsHTML += '<div style="margin-bottom: 1rem;"><strong>üí° What you can try:</strong><ul style="margin: 0.5rem 0; padding-left: 1.5rem;">';
                    AppState.errorDetails.recoveryActions.forEach(action => {
                        detailsHTML += `<li style="margin: 0.25rem 0;">${action}</li>`;
                    });
                    detailsHTML += '</ul></div>';
                }
                
                // Show technical details if available (collapsible)
                if (AppState.errorDetails.technicalDetails) {
                    detailsHTML += `
                        <details style="margin-top: 1rem;">
                            <summary style="cursor: pointer; font-weight: 600; color: #495057;">üîß Technical Details</summary>
                            <div style="margin-top: 0.5rem; padding: 0.75rem; background: rgba(0,0,0,0.05); border-radius: 4px; font-family: monospace; font-size: 0.8rem; word-break: break-all;">
                                ${AppState.errorDetails.technicalDetails}
                            </div>
                        </details>
                    `;
                }
                
                // Show basic details if provided and no enhanced details
                if (!detailsHTML && details) {
                    detailsHTML = details;
                }
                
                if (detailsHTML) {
                    errorDetailsEl.innerHTML = detailsHTML;
                    errorDetailsEl.style.display = 'block';
                } else {
                    errorDetailsEl.style.display = 'none';
                }
            }
            
            // Enhanced retry button with smart retry logic
            const retryButton = document.getElementById('retryBtn');
            if (retryButton) {
                // Reset button styles
                retryButton.style.color = 'white';
                
                switch (type) {
                    case 'network':
                        retryButton.textContent = 'üîÑ Check Connection & Retry';
                        retryButton.style.background = 'linear-gradient(135deg, #17a2b8 0%, #138496 100%)';
                        retryButton.title = 'Check your internet connection and try again';
                        break;
                    case 'timeout':
                        retryButton.textContent = '‚è±Ô∏è Retry Request';
                        retryButton.style.background = 'linear-gradient(135deg, #ffc107 0%, #e0a800 100%)';
                        retryButton.style.color = '#212529';
                        retryButton.title = 'The request timed out. Try again with a fresh request.';
                        break;
                    case 'cors':
                        retryButton.textContent = 'üîí Retry (CORS Issue)';
                        retryButton.style.background = 'linear-gradient(135deg, #6f42c1 0%, #59359a 100%)';
                        retryButton.title = 'CORS configuration issue. Retry may not work until CORS is fixed.';
                        break;
                    case 'configuration':
                        retryButton.textContent = '‚öôÔ∏è Configuration Issue';
                        retryButton.style.background = 'linear-gradient(135deg, #6c757d 0%, #545b62 100%)';
                        retryButton.title = 'Configuration problem detected. Contact administrator.';
                        break;
                    case 'api_error':
                        retryButton.textContent = 'üîß Retry API Call';
                        retryButton.style.background = 'linear-gradient(135deg, #fd7e14 0%, #e55a00 100%)';
                        retryButton.title = 'API server error. Retry may resolve temporary issues.';
                        break;
                    case 'lambda_error':
                        retryButton.textContent = '‚ö° Retry Lambda';
                        retryButton.style.background = 'linear-gradient(135deg, #e83e8c 0%, #d91a72 100%)';
                        retryButton.title = 'Lambda function error. Check function logs and configuration.';
                        break;
                    case 's3_error':
                        retryButton.textContent = 'üóÇÔ∏è Retry S3 Access';
                        retryButton.style.background = 'linear-gradient(135deg, #20c997 0%, #1aa179 100%)';
                        retryButton.title = 'S3 bucket access error. Check bucket permissions and existence.';
                        break;
                    case 'parse_error':
                        retryButton.textContent = 'üìÑ Retry Parse';
                        retryButton.style.background = 'linear-gradient(135deg, #6610f2 0%, #520dc2 100%)';
                        retryButton.title = 'Data parsing error. The server response format may be invalid.';
                        break;
                    case 'validation_error':
                        retryButton.textContent = '‚úÖ Retry Validation';
                        retryButton.style.background = 'linear-gradient(135deg, #fd7e14 0%, #e55a00 100%)';
                        retryButton.title = 'Data validation error. The server returned invalid data.';
                        break;
                    default:
                        retryButton.textContent = 'üîÑ Retry';
                        retryButton.style.background = 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
                        retryButton.title = 'General error. Try again to see if the issue resolves.';
                }
                
                // Add retry attempt counter
                if (!retryButton.dataset.attempts) {
                    retryButton.dataset.attempts = '0';
                }
                const attempts = parseInt(retryButton.dataset.attempts);
                if (attempts > 0) {
                    retryButton.textContent += ` (Attempt ${attempts + 1})`;
                }
            }
            
            // Add error animation with enhanced effects
            errorState.style.animation = 'slideInFromTop 0.4s ease-out';
            
            // Auto-focus retry button for keyboard accessibility
            setTimeout(() => {
                if (retryButton && document.activeElement !== retryButton) {
                    retryButton.focus();
                }
            }, 500);
        }

        // Show Success State
        function showSuccess(message = 'Photos loaded successfully!', photoCount = 0) {
            // Hide other states
            loadingState.style.display = 'none';
            errorState.style.display = 'none';
            
            // Update success message
            const successText = document.getElementById('successText');
            if (successText) {
                const countText = photoCount > 0 ? ` (${photoCount} photos)` : '';
                successText.textContent = message + countText;
            }
            
            // Show success message briefly
            const successMessage = document.getElementById('successMessage');
            successMessage.style.display = 'block';
            
            // Auto-hide success message after 3 seconds
            setTimeout(() => {
                successMessage.style.animation = 'fadeOut 0.5s ease-out';
                setTimeout(() => {
                    successMessage.style.display = 'none';
                    successMessage.style.animation = '';
                }, 500);
            }, 3000);
        }

        // Clear all feedback states
        function clearAllFeedback() {
            loadingState.style.display = 'none';
            errorState.style.display = 'none';
            document.getElementById('successMessage').style.display = 'none';
        }

        // Enhanced Retry Button Handler
        // Enhanced Retry Button Handler with smart retry logic and attempt tracking
        function handleRetry() {
            console.log('Retry button clicked');
            
            // Track retry attempts
            const retryButton = document.getElementById('retryBtn');
            let attempts = 0;
            if (retryButton && retryButton.dataset.attempts) {
                attempts = parseInt(retryButton.dataset.attempts);
            }
            attempts++;
            
            if (retryButton) {
                retryButton.dataset.attempts = attempts.toString();
            }
            
            console.log(`Retry attempt #${attempts}`);
            
            // Cancel any ongoing request
            apiService.cancelRequest();
            
            // Clear all states
            StateManager.clearError();
            clearAllFeedback();
            
            // Smart retry delay based on attempt number (exponential backoff)
            const retryDelay = Math.min(500 * Math.pow(1.5, attempts - 1), 3000); // Max 3 seconds
            
            // Show immediate feedback with attempt info
            showLoading(`Retrying connection... (Attempt ${attempts})`);
            
            // Add progressive delay for multiple attempts
            setTimeout(() => {
                // Reset attempts counter after successful retry or max attempts
                if (attempts >= 5) {
                    console.warn('Maximum retry attempts reached. Consider checking configuration.');
                    showError(
                        'Multiple retry attempts failed. There may be a persistent issue.',
                        'network',
                        'After 5 attempts, the issue appears to be persistent. Please check your connection and API configuration.'
                    );
                    if (retryButton) {
                        retryButton.dataset.attempts = '0'; // Reset for next time
                    }
                    return;
                }
                
                // Attempt the request again
                handleSeePhotos().then(() => {
                    // Success - reset retry counter
                    if (retryButton) {
                        retryButton.dataset.attempts = '0';
                    }
                }).catch((error) => {
                    // Error handling is already done in handleSeePhotos
                    console.log('Retry failed:', error.message);
                });
                
            }, retryDelay);
        }

        // Show Placeholder Photos (for testing layout)
        function showPlaceholderPhotos() {
            const placeholderPhotoData = [
                { 
                    url: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iZ3JhZCIgeDE9IjAlIiB5MT0iMCUiIHgyPSIxMDAlIiB5Mj0iMTAwJSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiNmOGY5ZmE7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICAgIDxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2U5ZWNlZjtzdG9wLW9wYWNpdHk6MSIgLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgPC9kZWZzPgogIDxyZWN0IHdpZHRoPSIzMDAiIGhlaWdodD0iMjIwIiBmaWxsPSJ1cmwoI2dyYWQpIi8+CiAgPHRleHQgeD0iNTAlIiB5PSI0NSUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzZjNzU3ZCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkZhbWlseSBQaG90bzwvdGV4dD4KICA8dGV4dCB4PSI1MCUiIHk9IjU1JSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjEyIiBmaWxsPSIjOTY5Yjk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+UGxhY2Vob2xkZXI8L3RleHQ+Cjwvc3ZnPg==',
                    key: 'upload/family-vacation.jpg', 
                    lastModified: '2023-07-15T10:30:00Z', 
                    size: 2411724,
                    metadata: { 
                        title: 'Family Vacation', 
                        description: 'Beautiful memories from our summer vacation',
                        tags: ['vacation', 'family', 'summer']
                    }
                },
                { 
                    url: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iZ3JhZCIgeDE9IjAlIiB5MT0iMCUiIHgyPSIxMDAlIiB5Mj0iMTAwJSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiNmOGY5ZmE7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICAgIDxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2U5ZWNlZjtzdG9wLW9wYWNpdHk6MSIgLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgPC9kZWZzPgogIDxyZWN0IHdpZHRoPSIzMDAiIGhlaWdodD0iMjIwIiBmaWxsPSJ1cmwoI2dyYWQpIi8+CiAgPHRleHQgeD0iNTAlIiB5PSI0NSUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzZjNzU3ZCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkZhbWlseSBQaG90bzwvdGV4dD4KICA8dGV4dCB4PSI1MCUiIHk9IjU1JSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjEyIiBmaWxsPSIjOTY5Yjk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+UGxhY2Vob2xkZXI8L3RleHQ+Cjwvc3ZnPg==',
                    key: 'upload/birthday-party.jpg', 
                    lastModified: '2023-08-22T15:45:00Z', 
                    size: 1887436,
                    metadata: { 
                        title: 'Birthday Party',
                        description: 'Celebrating another year of joy and laughter',
                        tags: ['birthday', 'celebration', 'family']
                    }
                },
                { 
                    url: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iZ3JhZCIgeDE9IjAlIiB5MT0iMCUiIHgyPSIxMDAlIiB5Mj0iMTAwJSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiNmOGY5ZmE7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICAgIDxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2U5ZWNlZjtzdG9wLW9wYWNpdHk6MSIgLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgPC9kZWZzPgogIDxyZWN0IHdpZHRoPSIzMDAiIGhlaWdodD0iMjIwIiBmaWxsPSJ1cmwoI2dyYWQpIi8+CiAgPHRleHQgeD0iNTAlIiB5PSI0NSUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzZjNzU3ZCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkZhbWlseSBQaG90bzwvdGV4dD4KICA8dGV4dCB4PSI1MCUiIHk9IjU1JSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjEyIiBmaWxsPSIjOTY5Yjk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+UGxhY2Vob2xkZXI8L3RleHQ+Cjwvc3ZnPg==',
                    key: 'upload/holiday-gathering.jpg', 
                    lastModified: '2023-12-25T18:20:00Z', 
                    size: 3251789,
                    metadata: { 
                        title: 'Holiday Gathering',
                        description: '',  // Test empty description
                        tags: ['holiday', 'christmas', 'family']
                    }
                },
                { 
                    url: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iZ3JhZCIgeDE9IjAlIiB5MT0iMCUiIHgyPSIxMDAlIiB5Mj0iMTAwJSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiNmOGY5ZmE7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICAgIDxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2U5ZWNlZjtzdG9wLW9wYWNpdHk6MSIgLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgPC9kZWZzPgogIDxyZWN0IHdpZHRoPSIzMDAiIGhlaWdodD0iMjIwIiBmaWxsPSJ1cmwoI2dyYWQpIi8+CiAgPHRleHQgeD0iNTAlIiB5PSI0NSUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzZjNzU3ZCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkZhbWlseSBQaG90bzwvdGV4dD4KICA8dGV4dCB4PSI1MCUiIHk9IjU1JSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjEyIiBmaWxsPSIjOTY5Yjk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+UGxhY2Vob2xkZXI8L3RleHQ+Cjwvc3ZnPg==',
                    key: 'upload/summer_picnic.jpg', 
                    lastModified: '2023-06-10T12:15:00Z', 
                    size: 2834567,
                    metadata: {}  // Test missing metadata
                },
                { 
                    url: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iZ3JhZCIgeDE9IjAlIiB5MT0iMCUiIHgyPSIxMDAlIiB5Mj0iMTAwJSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiNmOGY5ZmE7c3RvcC1vcGFjaXR5OjEiIC0+CiAgICAgIDxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2U5ZWNlZjtzdG9wLW9wYWNpdHk6MSIgLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgPC9kZWZzPgogIDxyZWN0IHdpZHRoPSIzMDAiIGhlaWdodD0iMjIwIiBmaWxsPSJ1cmwoI2dyYWQpIi8+CiAgPHRleHQgeD0iNTAlIiB5PSI0NSUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzZjNzU3ZCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkZhbWlseSBQaG90bzwvdGV4dD4KICA8dGV4dCB4PSI1MCUiIHk9IjU1JSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjEyIiBmaWxsPSIjOTY5Yjk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+UGxhY2Vob2xkZXI8L3RleHQ+Cjwvc3ZnPg==',
                    key: 'upload/beach-day.jpg', 
                    lastModified: '2023-09-05T14:30:00Z', 
                    size: 1993847,
                    metadata: { 
                        title: 'Beach Day',
                        description: 'Fun in the sun at the beach',
                        tags: 'beach,summer,fun'  // Test string tags
                    }
                },
                { 
                    url: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iZ3JhZCIgeDE9IjAlIiB5MT0iMCUiIHgyPSIxMDAlIiB5Mj0iMTAwJSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiNmOGY5ZmE7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICAgIDxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2U5ZWNlZjtzdG9wLW9wYWNpdHk6MSIgLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgPC9kZWZzPgogIDxyZWN0IHdpZHRoPSIzMDAiIGhlaWdodD0iMjIwIiBmaWxsPSJ1cmwoI2dyYWQpIi8+CiAgPHRleHQgeD0iNTAlIiB5PSI0NSUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzZjNzU3ZCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkZhbWlseSBQaG90bzwvdGV4dD4KICA8dGV4dCB4PSI1MCUiIHk9IjU1JSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjEyIiBmaWxsPSIjOTY5Yjk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+UGxhY2Vob2xkZXI8L3RleHQ+Cjwvc3ZnPg==',
                    key: 'upload/graduation.jpg', 
                    lastModified: '2023-05-20T16:00:00Z', 
                    size: 2945123,
                    metadata: { 
                        title: 'Graduation',
                        description: 'A proud moment in our family history',
                        tags: ['graduation', 'achievement', 'family', 'milestone']
                    }
                }
            ];

            // Use StateManager to set photos
            StateManager.setPhotos(placeholderPhotoData);
            
            // Show success message for placeholder photos
            showSuccess('Placeholder photos loaded for development', placeholderPhotoData.length);
            
            // Render photos using the Photo class methods
            renderPhotos();
        }

        // Lazy Loading Implementation using Intersection Observer
        let imageObserver = null;

        function initializeLazyLoading() {
            if ('IntersectionObserver' in window) {
                imageObserver = new IntersectionObserver((entries, observer) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target;
                            const photoCard = img.closest('.photo-card');
                            
                            // Load the image
                            loadLazyImage(img, photoCard);
                            
                            // Stop observing this image
                            observer.unobserve(img);
                        }
                    });
                }, {
                    rootMargin: '50px 0px', // Start loading 50px before image enters viewport
                    threshold: 0.1
                });
            }
        }

        function loadLazyImage(img, photoCard) {
            const actualSrc = img.dataset.src;
            if (!actualSrc) return;
            
            // Add loading class for visual feedback
            photoCard.classList.add('lazy-loading');
            
            // Create a new image to preload
            const imageLoader = new Image();
            
            imageLoader.onload = () => {
                // Image loaded successfully
                img.src = actualSrc;
                img.removeAttribute('data-lazy');
                img.classList.add('loaded');
                photoCard.classList.remove('lazy-loading');
                photoCard.classList.add('lazy-loaded');
                
                // Trigger the existing load handler
                handleImageLoad(img);
            };
            
            imageLoader.onerror = () => {
                // Image failed to load
                photoCard.classList.remove('lazy-loading');
                handleImageError(img);
            };
            
            // Start loading
            imageLoader.src = actualSrc;
        }

        // Enhanced photo rendering with lazy loading and accessibility
        function renderPhotos() {
            photoGrid.innerHTML = '';
            
            // Initialize lazy loading if not already done
            if (!imageObserver) {
                initializeLazyLoading();
            }
            
            AppState.photos.forEach((photo, index) => {
                const photoCard = document.createElement('div');
                photoCard.className = 'photo-card';
                photoCard.style.animationDelay = `${index * 0.1}s`;
                
                const metadata = photo.getMetadataSummary();
                const tags = metadata.tags.length > 0 ? 
                    `<div><span class="sr-only">Tags: </span>${metadata.tags.join(', ')}</div>` : '';
                const description = metadata.description ? 
                    `<div><span class="sr-only">Description: </span>${metadata.description}</div>` : '';
                
                // Create image element with lazy loading
                const isLazyLoadSupported = imageObserver !== null;
                const imgSrc = isLazyLoadSupported ? '' : photo.url;
                const imgDataSrc = isLazyLoadSupported ? photo.url : '';
                const lazyAttr = isLazyLoadSupported ? 'data-lazy' : '';
                
                photoCard.innerHTML = `
                    <img src="${imgSrc}" 
                         ${imgDataSrc ? `data-src="${imgDataSrc}"` : ''}
                         ${lazyAttr}
                         alt="${metadata.name}" 
                         loading="lazy" 
                         onload="handleImageLoad(this)" 
                         onerror="handleImageError(this)"
                         aria-describedby="photo-${index}-desc">
                    <div class="photo-info">
                        <div class="photo-title">${metadata.name}</div>
                        <div class="photo-meta" id="photo-${index}-desc">
                            <div><span class="sr-only">Date: </span>${metadata.date}</div>
                            <div><span class="sr-only">Size: </span>${metadata.size}</div>
                            ${description}
                            ${tags}
                        </div>
                    </div>
                `;
                
                // Add loading state to photo card initially
                photoCard.classList.add('loading');
                
                // Enhanced accessibility attributes
                photoCard.setAttribute('tabindex', '0');
                photoCard.setAttribute('role', 'button');
                photoCard.setAttribute('aria-label', `View details for ${metadata.name}. Photo taken on ${metadata.date}, size ${metadata.size}`);
                
                // Add keyboard navigation support
                photoCard.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        showPhotoDetail(photo);
                        announceToScreenReader(`Opening details for ${metadata.name}`);
                    } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
                        e.preventDefault();
                        focusNextPhoto(photoCard);
                    } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                        e.preventDefault();
                        focusPreviousPhoto(photoCard);
                    } else if (e.key === 'Home') {
                        e.preventDefault();
                        focusFirstPhoto();
                    } else if (e.key === 'End') {
                        e.preventDefault();
                        focusLastPhoto();
                    }
                });
                
                // Add click handler for photo detail view interaction
                photoCard.addEventListener('click', () => {
                    console.log('Photo clicked:', photo.getMetadataSummary());
                    showPhotoDetail(photo);
                });
                
                // Add focus management
                photoCard.addEventListener('focus', () => {
                    announceToScreenReader(`Focused on ${metadata.name}`);
                });
                
                photoGrid.appendChild(photoCard);
                
                // Start lazy loading observation if supported
                if (imageObserver && isLazyLoadSupported) {
                    const img = photoCard.querySelector('img');
                    imageObserver.observe(img);
                }
            });
            
            // Announce to screen readers
            announceToScreenReader(`${AppState.photos.length} photos loaded in gallery`);
        }

        // Handle individual image loading success
        function handleImageLoad(img) {
            const photoCard = img.closest('.photo-card');
            if (photoCard) {
                photoCard.classList.remove('loading');
                img.style.opacity = '0';
                img.style.transition = 'opacity 0.3s ease';
                setTimeout(() => {
                    img.style.opacity = '1';
                }, 50);
            }
        }

        // Handle individual image loading errors
        // Enhanced image loading error handling with comprehensive fallbacks and retry logic
        function handleImageError(img) {
            const photoCard = img.closest('.photo-card');
            if (!photoCard) return;
            
            // Track retry attempts for this image
            if (!img.dataset.retryAttempts) {
                img.dataset.retryAttempts = '0';
            }
            
            const retryAttempts = parseInt(img.dataset.retryAttempts);
            const originalSrc = img.dataset.originalSrc || img.src;
            
            // Store original source for retry attempts
            if (!img.dataset.originalSrc) {
                img.dataset.originalSrc = originalSrc;
            }
            
            console.log(`Image loading failed for ${originalSrc}, attempt ${retryAttempts + 1}`);
            
            // Try different strategies based on retry attempts
            if (retryAttempts < 2) {
                // First retry: try loading the image again with cache busting
                img.dataset.retryAttempts = (retryAttempts + 1).toString();
                
                setTimeout(() => {
                    const cacheBustUrl = originalSrc + (originalSrc.includes('?') ? '&' : '?') + 'retry=' + Date.now();
                    console.log(`Retrying image load with cache busting: ${cacheBustUrl}`);
                    img.src = cacheBustUrl;
                }, 1000 * (retryAttempts + 1)); // Progressive delay
                
                return;
            }
            
            // After retries failed, show enhanced placeholder
            photoCard.classList.remove('loading');
            photoCard.classList.add('image-error');
            
            // Create enhanced placeholder with error information
            const errorPlaceholder = createImageErrorPlaceholder(originalSrc, retryAttempts);
            img.src = errorPlaceholder;
            img.alt = 'üì∑ Image not available';
            
            // Add error styling to the image
            img.style.background = 'linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%)';
            img.style.border = '2px dashed #dee2e6';
            img.style.borderRadius = '8px';
            img.style.objectFit = 'contain';
            
            // Add retry button overlay for manual retry
            addImageRetryOverlay(photoCard, img, originalSrc);
            
            // Log error for debugging
            console.error(`Image failed to load after ${retryAttempts + 1} attempts:`, originalSrc);
        }
        
        // Create enhanced error placeholder with detailed information
        function createImageErrorPlaceholder(originalUrl, attempts) {
            const errorInfo = getImageErrorInfo(originalUrl);
            
            const svg = `
                <svg width="300" height="220" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="errorGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#f8f9fa;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#e9ecef;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <rect width="300" height="220" fill="url(#errorGrad)" stroke="#dee2e6" stroke-width="2" stroke-dasharray="5,5"/>
                    <text x="50%" y="35%" font-family="Arial, sans-serif" font-size="24" fill="#dc3545" text-anchor="middle" dy=".3em">üì∑</text>
                    <text x="50%" y="50%" font-family="Arial, sans-serif" font-size="14" fill="#6c757d" text-anchor="middle" dy=".3em">Image not available</text>
                    <text x="50%" y="65%" font-family="Arial, sans-serif" font-size="10" fill="#adb5bd" text-anchor="middle" dy=".3em">${errorInfo}</text>
                    <text x="50%" y="80%" font-family="Arial, sans-serif" font-size="8" fill="#adb5bd" text-anchor="middle" dy=".3em">Attempts: ${attempts + 1}</text>
                </svg>
            `;
            
            return 'data:image/svg+xml;base64,' + btoa(svg);
        }
        
        // Get error information based on URL analysis
        function getImageErrorInfo(url) {
            if (!url || url === '') return 'No URL provided';
            if (url.startsWith('data:')) return 'Data URL error';
            if (url.includes('localhost') || url.includes('127.0.0.1')) return 'Local server error';
            if (url.includes('amazonaws.com')) return 'AWS S3 access error';
            if (url.includes('cloudfront.net')) return 'CloudFront error';
            if (!url.startsWith('http')) return 'Invalid URL format';
            return 'Network or server error';
        }
        
        // Add retry button overlay for manual image retry
        function addImageRetryOverlay(photoCard, img, originalSrc) {
            // Remove existing retry overlay if present
            const existingOverlay = photoCard.querySelector('.image-retry-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
            
            // Create retry overlay
            const retryOverlay = document.createElement('div');
            retryOverlay.className = 'image-retry-overlay';
            retryOverlay.style.cssText = `
                position: absolute;
                top: 8px;
                right: 8px;
                background: rgba(220, 53, 69, 0.9);
                color: white;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 0.7rem;
                cursor: pointer;
                z-index: 10;
                transition: all 0.3s ease;
                user-select: none;
            `;
            retryOverlay.textContent = 'üîÑ Retry';
            retryOverlay.title = 'Click to retry loading this image';
            
            // Add hover effect
            retryOverlay.addEventListener('mouseenter', () => {
                retryOverlay.style.background = 'rgba(220, 53, 69, 1)';
                retryOverlay.style.transform = 'scale(1.05)';
            });
            
            retryOverlay.addEventListener('mouseleave', () => {
                retryOverlay.style.background = 'rgba(220, 53, 69, 0.9)';
                retryOverlay.style.transform = 'scale(1)';
            });
            
            // Add retry functionality
            retryOverlay.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent photo detail modal from opening
                
                console.log('Manual image retry requested for:', originalSrc);
                
                // Reset retry attempts and try again
                img.dataset.retryAttempts = '0';
                photoCard.classList.remove('image-error');
                photoCard.classList.add('loading');
                retryOverlay.remove();
                
                // Show loading state
                img.style.opacity = '0.5';
                img.style.filter = 'blur(2px)';
                
                // Retry with fresh cache-busted URL
                const freshUrl = originalSrc + (originalSrc.includes('?') ? '&' : '?') + 'manual_retry=' + Date.now();
                img.src = freshUrl;
            });
            
            // Make photo card position relative if not already
            if (getComputedStyle(photoCard).position === 'static') {
                photoCard.style.position = 'relative';
            }
            
            photoCard.appendChild(retryOverlay);
        }

        // Set up state change listeners
        function setupStateListeners() {
            // Listen for loading state changes
            StateManager.addEventListener('loading', (isLoading) => {
                if (isLoading) {
                    // Loading state is now managed by the enhanced showLoading function
                    // which is called directly from handleSeePhotos
                } else {
                    hideLoading();
                }
            });
            
            // Listen for error state changes
            StateManager.addEventListener('error', (errorDetails) => {
                // Enhanced error display with details
                const details = errorDetails.code ? 
                    `Error Code: ${errorDetails.code} | Type: ${errorDetails.type}` : 
                    null;
                showError(errorDetails.message, errorDetails.type, details);
            });
            
            // Listen for error cleared
            StateManager.addEventListener('errorCleared', () => {
                errorState.style.display = 'none';
            });
            
            // Listen for photo updates
            StateManager.addEventListener('photos', (photos) => {
                console.log('Photos updated:', photos.length, 'photos loaded');
            });
            
            // Listen for flow step updates (for architecture visualization)
            StateManager.addEventListener('flowStepUpdated', ({ stepIndex, step, previousStatus }) => {
                updateArchitectureVisualization(stepIndex, step, previousStatus);
            });
            
            // Listen for flow start
            StateManager.addEventListener('flowStarted', (flowState) => {
                console.log('Flow started');
                resetArchitectureVisualization();
                startMetricsUpdates();
            });
            
            // Listen for flow completion
            StateManager.addEventListener('flowCompleted', ({ flowState, success }) => {
                console.log('Flow completed in', flowState.totalDuration, 'ms', success ? '(Success)' : '(Failed)');
                stopMetricsUpdates();
                updateMetricsDisplay();
            });
            
            // Listen for general state changes (for debugging)
            StateManager.addEventListener('stateChanged', ({ event, data }) => {
                console.log('State changed:', event, data);
            });
        }

        // Enhanced architecture visualization with real-time timing
        function updateArchitectureVisualization(stepIndex, step, previousStatus) {
            if (!AppState.showArchitecture) return;
            
            const stepElement = document.getElementById(`step-${stepIndex}`);
            const statusElement = document.getElementById(`step-${stepIndex}-status`);
            const timingElement = document.getElementById(`step-${stepIndex}-timing`);
            
            if (!stepElement || !statusElement || !timingElement) return;
            
            // Remove previous status classes
            stepElement.classList.remove('idle', 'active', 'complete', 'error');
            
            // Add current status class
            stepElement.classList.add(step.status);
            
            // Update step content with real-time information
            let statusText = '';
            let timingText = '-';
            
            switch (step.status) {
                case 'idle':
                    statusText = 'Ready';
                    stepElement.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    stepElement.style.transform = 'scale(1)';
                    break;
                    
                case 'active':
                    statusText = 'Processing...';
                    timingText = 'In progress';
                    stepElement.style.background = 'linear-gradient(135deg, #ffc107 0%, #ff8c00 100%)';
                    stepElement.style.transform = 'scale(1.05)';
                    
                    // Start real-time timer for active step
                    startStepTimer(stepIndex);
                    break;
                    
                case 'complete':
                    statusText = 'Complete ‚úì';
                    if (step.duration) {
                        timingText = formatDuration(step.duration);
                    }
                    stepElement.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                    stepElement.style.transform = 'scale(1)';
                    
                    // Stop timer for this step
                    stopStepTimer(stepIndex);
                    break;
                    
                case 'error':
                    statusText = 'Error ‚úó';
                    if (step.duration) {
                        timingText = formatDuration(step.duration);
                    }
                    stepElement.style.background = 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
                    stepElement.style.transform = 'scale(1)';
                    
                    // Stop timer for this step
                    stopStepTimer(stepIndex);
                    break;
            }
            
            // Update DOM elements
            statusElement.textContent = statusText;
            timingElement.textContent = timingText;
            
            // Update tooltip with details
            if (step.details) {
                stepElement.title = step.details;
            }
            
            // Update overall flow timing
            updateFlowTiming();
        }

        // Real-time step timers
        const stepTimers = new Map();

        function startStepTimer(stepIndex) {
            // Clear any existing timer
            stopStepTimer(stepIndex);
            
            const timingElement = document.getElementById(`step-${stepIndex}-timing`);
            if (!timingElement) return;
            
            const startTime = Date.now();
            const timer = setInterval(() => {
                const elapsed = Date.now() - startTime;
                timingElement.textContent = formatDuration(elapsed);
            }, 100); // Update every 100ms for smooth animation
            
            stepTimers.set(stepIndex, timer);
        }

        function stopStepTimer(stepIndex) {
            const timer = stepTimers.get(stepIndex);
            if (timer) {
                clearInterval(timer);
                stepTimers.delete(stepIndex);
            }
        }

        // Format duration for display
        function formatDuration(milliseconds) {
            if (milliseconds < 1000) {
                return `${milliseconds}ms`;
            } else if (milliseconds < 60000) {
                return `${(milliseconds / 1000).toFixed(1)}s`;
            } else {
                const minutes = Math.floor(milliseconds / 60000);
                const seconds = ((milliseconds % 60000) / 1000).toFixed(1);
                return `${minutes}m ${seconds}s`;
            }
        }

        // Update overall flow timing display
        function updateFlowTiming() {
            const flowTimingElement = document.getElementById('flowTiming');
            if (!flowTimingElement) return;
            
            if (FlowState.isActive && FlowState.flowStartTime) {
                const elapsed = Date.now() - FlowState.flowStartTime.getTime();
                flowTimingElement.textContent = `Active: ${formatDuration(elapsed)}`;
                flowTimingElement.className = 'flow-timing active';
            } else if (FlowState.totalDuration) {
                flowTimingElement.textContent = `Completed in ${formatDuration(FlowState.totalDuration)}`;
                flowTimingElement.className = 'flow-timing complete';
            } else {
                flowTimingElement.textContent = 'Ready to start';
                flowTimingElement.className = 'flow-timing';
            }
        }

        // Update metrics display
        function updateMetricsDisplay() {
            if (!AppState.showArchitecture) return;
            
            const metrics = FlowState.metrics;
            
            // Total time
            const totalTimeElement = document.getElementById('total-time-value');
            if (totalTimeElement) {
                if (FlowState.isActive && FlowState.flowStartTime) {
                    const elapsed = Date.now() - FlowState.flowStartTime.getTime();
                    totalTimeElement.textContent = formatDuration(elapsed);
                    document.getElementById('metric-total-time').className = 'metric active';
                } else if (FlowState.totalDuration) {
                    totalTimeElement.textContent = formatDuration(FlowState.totalDuration);
                    document.getElementById('metric-total-time').className = 'metric complete';
                } else {
                    totalTimeElement.textContent = '-';
                    document.getElementById('metric-total-time').className = 'metric';
                }
            }
            
            // Request count
            const requestCountElement = document.getElementById('request-count-value');
            if (requestCountElement) {
                requestCountElement.textContent = metrics.totalRequests;
            }
            
            // Success rate
            const successRateElement = document.getElementById('success-rate-value');
            if (successRateElement) {
                if (metrics.totalRequests > 0) {
                    successRateElement.textContent = `${metrics.successRate}%`;
                } else {
                    successRateElement.textContent = '-';
                }
            }
            
            // Average time
            const avgTimeElement = document.getElementById('avg-time-value');
            if (avgTimeElement) {
                if (metrics.averageTime > 0) {
                    avgTimeElement.textContent = formatDuration(metrics.averageTime);
                } else {
                    avgTimeElement.textContent = '-';
                }
            }
        }

        // Start real-time metrics updates when flow is active
        let metricsUpdateTimer = null;

        function startMetricsUpdates() {
            stopMetricsUpdates();
            metricsUpdateTimer = setInterval(() => {
                updateFlowTiming();
                updateMetricsDisplay();
            }, 100);
        }

        function stopMetricsUpdates() {
            if (metricsUpdateTimer) {
                clearInterval(metricsUpdateTimer);
                metricsUpdateTimer = null;
            }
        }

        // Reset architecture visualization
        function resetArchitectureVisualization() {
            // Stop all timers
            stepTimers.forEach((timer, stepIndex) => {
                clearInterval(timer);
            });
            stepTimers.clear();
            stopMetricsUpdates();
            
            // Reset all steps to idle state
            for (let i = 0; i < FlowState.steps.length; i++) {
                const stepElement = document.getElementById(`step-${i}`);
                const statusElement = document.getElementById(`step-${i}-status`);
                const timingElement = document.getElementById(`step-${i}-timing`);
                
                if (stepElement && statusElement && timingElement) {
                    stepElement.classList.remove('idle', 'active', 'complete', 'error');
                    stepElement.classList.add('idle');
                    stepElement.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    stepElement.style.transform = 'scale(1)';
                    
                    statusElement.textContent = i === 0 ? 'Ready' : 'Waiting';
                    timingElement.textContent = '-';
                }
            }
            
            // Reset flow timing
            updateFlowTiming();
            updateMetricsDisplay();
        }



        // Test Architecture Visualization System
        function testArchitectureVisualization() {
            console.log('Testing architecture visualization system...');
            
            // Test 1: Toggle architecture diagram
            console.log('‚úì Test 1: Testing architecture diagram toggle');
            if (!AppState.showArchitecture) {
                toggleArchitecture();
            }
            
            // Test 2: Simulate flow visualization
            console.log('‚úì Test 2: Testing real-time flow visualization');
            setTimeout(() => {
                StateManager.startFlow();
                
                // Simulate step progression with timing
                setTimeout(() => StateManager.updateFlowStep(0, 'active', 'Browser request initiated'), 200);
                setTimeout(() => StateManager.updateFlowStep(0, 'complete', 'Request sent successfully'), 500);
                setTimeout(() => StateManager.updateFlowStep(1, 'active', 'API Gateway processing'), 600);
                setTimeout(() => StateManager.updateFlowStep(1, 'complete', 'API Gateway processed'), 900);
                setTimeout(() => StateManager.updateFlowStep(2, 'active', 'Lambda function executing'), 1000);
                setTimeout(() => StateManager.updateFlowStep(2, 'complete', 'Lambda completed'), 1400);
                setTimeout(() => StateManager.updateFlowStep(3, 'active', 'Accessing S3 bucket'), 1500);
                setTimeout(() => StateManager.updateFlowStep(3, 'complete', 'S3 data retrieved'), 1800);
                setTimeout(() => StateManager.updateFlowStep(4, 'active', 'Processing response'), 1900);
                setTimeout(() => {
                    StateManager.updateFlowStep(4, 'complete', 'Response processed');
                    StateManager.completeFlow(true);
                    console.log('‚úì Test 3: Flow visualization completed successfully');
                    console.log('‚úì Test 4: Real-time timing and metrics updated');
                    console.log('üéâ Architecture visualization system tests passed!');
                }, 2200);
                
            }, 1000);
        }

        // Test Photo Grid Display Functionality
        function testPhotoGridDisplay() {
            console.log('Testing photo grid display functionality...');
            
            // Test 1: Photo card rendering with metadata
            console.log('‚úì Test 1: Photo card rendering with metadata');
            showPlaceholderPhotos();
            
            // Test 2: Responsive image loading and sizing
            console.log('‚úì Test 2: Responsive image loading and sizing (CSS Grid implemented)');
            
            // Test 3: Photo detail view interaction
            console.log('‚úì Test 3: Photo detail view interaction (Modal implemented)');
            
            // Test 4: Handle missing or incomplete metadata gracefully
            console.log('‚úì Test 4: Missing/incomplete metadata handling (Implemented in Photo class)');
            
            // Test 5: Verify all photos are rendered
            setTimeout(() => {
                const renderedCards = document.querySelectorAll('.photo-card');
                console.log(`‚úì Test 5: ${renderedCards.length} photo cards rendered successfully`);
                
                // Test 6: Verify photo detail modal functionality
                if (renderedCards.length > 0) {
                    console.log('‚úì Test 6: Testing photo detail modal...');
                    const firstCard = renderedCards[0];
                    firstCard.click();
                    
                    setTimeout(() => {
                        const modal = document.getElementById('photoDetailModal');
                        if (modal.classList.contains('show')) {
                            console.log('‚úì Photo detail modal opened successfully');
                            
                            // Close modal after test
                            setTimeout(() => {
                                closePhotoDetail();
                                console.log('‚úì Photo detail modal closed successfully');
                                console.log('üéâ All photo grid display functionality tests passed!');
                            }, 1000);
                        } else {
                            console.error('‚ùå Photo detail modal failed to open');
                        }
                    }, 500);
                } else {
                    console.error('‚ùå No photo cards were rendered');
                }
            }, 1000);
        }

        // Accessibility and Keyboard Navigation Functions
        
        // Screen reader announcements
        function announceToScreenReader(message) {
            const announcement = document.createElement('div');
            announcement.setAttribute('aria-live', 'polite');
            announcement.setAttribute('aria-atomic', 'true');
            announcement.className = 'sr-only';
            announcement.textContent = message;
            
            document.body.appendChild(announcement);
            
            // Remove after announcement
            setTimeout(() => {
                document.body.removeChild(announcement);
            }, 1000);
        }

        // Keyboard navigation for photo grid
        function focusNextPhoto(currentPhoto) {
            const photos = Array.from(document.querySelectorAll('.photo-card'));
            const currentIndex = photos.indexOf(currentPhoto);
            const nextIndex = (currentIndex + 1) % photos.length;
            photos[nextIndex].focus();
        }

        function focusPreviousPhoto(currentPhoto) {
            const photos = Array.from(document.querySelectorAll('.photo-card'));
            const currentIndex = photos.indexOf(currentPhoto);
            const prevIndex = currentIndex === 0 ? photos.length - 1 : currentIndex - 1;
            photos[prevIndex].focus();
        }

        function focusFirstPhoto() {
            const firstPhoto = document.querySelector('.photo-card');
            if (firstPhoto) firstPhoto.focus();
        }

        function focusLastPhoto() {
            const photos = document.querySelectorAll('.photo-card');
            const lastPhoto = photos[photos.length - 1];
            if (lastPhoto) lastPhoto.focus();
        }

        // Enhanced keyboard navigation for the entire application
        function setupGlobalKeyboardNavigation() {
            document.addEventListener('keydown', (e) => {
                // Global keyboard shortcuts
                if (e.altKey && e.key === 'p') {
                    e.preventDefault();
                    document.getElementById('seePhotosBtn').focus();
                    announceToScreenReader('Focused on See Photos button');
                } else if (e.altKey && e.key === 'a') {
                    e.preventDefault();
                    document.getElementById('toggleArchitectureBtn').focus();
                    announceToScreenReader('Focused on Architecture toggle button');
                } else if (e.altKey && e.key === 'g') {
                    e.preventDefault();
                    focusFirstPhoto();
                    announceToScreenReader('Focused on photo gallery');
                }
            });
        }

        // Performance optimizations
        function optimizePerformance() {
            // Debounce resize events
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    // Recalculate layout if needed
                    updateResponsiveLayout();
                }, 250);
            });

            // Optimize scroll events for lazy loading
            let scrollTimeout;
            window.addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    // Additional scroll-based optimizations can go here
                }, 100);
            }, { passive: true });

            // Preload critical resources
            preloadCriticalResources();
        }

        function updateResponsiveLayout() {
            // Update grid layout based on viewport size
            const photoGrid = document.getElementById('photoGrid');
            if (!photoGrid) return;

            const viewportWidth = window.innerWidth;
            
            if (viewportWidth < 480) {
                photoGrid.classList.add('mobile-small');
            } else {
                photoGrid.classList.remove('mobile-small');
            }
        }

        function preloadCriticalResources() {
            // Preload placeholder image for better performance
            const placeholderImg = new Image();
            placeholderImg.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAwIiBoZWlnaHQ9IjIyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8ZGVmcz4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iZ3JhZCIgeDE9IjAlIiB5MT0iMCUiIHgyPSIxMDAlIiB5Mj0iMTAwJSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiNmOGY5ZmE7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICAgIDxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6I2U5ZWNlZjtzdG9wLW9wYWNpdHk6MSIgLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgPC9kZWZzPgogIDxyZWN0IHdpZHRoPSIzMDAiIGhlaWdodD0iMjIwIiBmaWxsPSJ1cmwoI2dyYWQpIi8+CiAgPHRleHQgeD0iNTAlIiB5PSI0NSUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzZjNzU3ZCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkZhbWlseSBQaG90bzwvdGV4dD4KICA8dGV4dCB4PSI1MCUiIHk9IjU1JSIgZm9udC1mYW1pbHk9IkFyaWFsLCBzYW5zLXNlcmlmIiBmb250LXNpemU9IjEyIiBmaWxsPSIjOTY5Yjk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+UGxhY2Vob2xkZXI8L3RleHQ+Cjwvc3ZnPg==';
        }

        // Demo Functions
        function updateDemoStatus(message) {
            const statusEl = document.getElementById('demoStatus');
            if (statusEl) {
                statusEl.textContent = message;
            }
        }

        function simulatePhotoLoad() {
            updateDemoStatus('Loading demo photos...');
            console.log('üé≠ Demo: Simulating photo load with high-quality mock data');
            
            // Clear any existing state
            StateManager.clearError();
            clearAllFeedback();
            
            // Show loading state
            StateManager.setLoading(true);
            showLoading('Loading beautiful demo photos...');
            
            // Simulate architecture flow
            StateManager.startFlow();
            StateManager.updateFlowStep(0, 'active', 'Demo: Browser request initiated');
            
            setTimeout(() => {
                StateManager.updateFlowStep(0, 'complete', 'Demo: Request sent successfully');
                StateManager.updateFlowStep(1, 'active', 'Demo: API Gateway processing');
            }, 500);
            
            setTimeout(() => {
                StateManager.updateFlowStep(1, 'complete', 'Demo: API Gateway processed');
                StateManager.updateFlowStep(2, 'active', 'Demo: Lambda function executing');
            }, 1000);
            
            setTimeout(() => {
                StateManager.updateFlowStep(2, 'complete', 'Demo: Lambda completed');
                StateManager.updateFlowStep(3, 'active', 'Demo: Accessing S3 bucket');
            }, 1500);
            
            setTimeout(() => {
                StateManager.updateFlowStep(3, 'complete', 'Demo: S3 data retrieved');
                StateManager.updateFlowStep(4, 'active', 'Demo: Processing response');
            }, 2000);
            
            setTimeout(() => {
                StateManager.updateFlowStep(4, 'complete', 'Demo: Response processed');
                StateManager.completeFlow(true);
                
                // Load high-quality demo photos
                showDemoPhotos();
                StateManager.setLoading(false);
                showSuccess('Demo photos loaded successfully!', 8);
                updateDemoStatus('‚úÖ Photos loaded');
            }, 2500);
        }

        function simulateArchitecture() {
            updateDemoStatus('Toggling architecture...');
            console.log('üé≠ Demo: Toggling architecture visualization');
            toggleArchitecture();
            updateDemoStatus('üèóÔ∏è Architecture toggled');
        }

        function simulateError() {
            updateDemoStatus('Simulating error...');
            console.log('üé≠ Demo: Simulating API error');
            
            StateManager.setLoading(false);
            clearAllFeedback();
            
            showError(
                'Demo Error: This is how errors are displayed in the application',
                'api_error',
                'This is a simulated error to demonstrate the comprehensive error handling system.'
            );
            updateDemoStatus('‚ö†Ô∏è Error simulated');
        }

        function simulateLoading() {
            updateDemoStatus('Showing loading state...');
            console.log('üé≠ Demo: Simulating loading state');
            
            StateManager.setLoading(true);
            showLoading('Demo: Simulating API request in progress...');
            
            setTimeout(() => {
                StateManager.setLoading(false);
                updateDemoStatus('‚è≥ Loading demo complete');
            }, 3000);
        }

        function showPhotoDetails() {
            updateDemoStatus('Opening photo details...');
            console.log('üé≠ Demo: Opening photo detail modal');
            
            if (AppState.photos.length > 0) {
                showPhotoDetail(AppState.photos[0]);
                updateDemoStatus('üîç Photo details opened');
            } else {
                // Load demo photos first
                showDemoPhotos();
                setTimeout(() => {
                    if (AppState.photos.length > 0) {
                        showPhotoDetail(AppState.photos[0]);
                        updateDemoStatus('üîç Photo details opened');
                    }
                }, 500);
            }
        }

        function resetDemo() {
            updateDemoStatus('Resetting demo...');
            console.log('üé≠ Demo: Resetting application state');
            
            StateManager.resetState();
            clearAllFeedback();
            photoGrid.innerHTML = '';
            
            // Hide architecture if shown
            if (AppState.showArchitecture) {
                toggleArchitecture();
            }
            
            updateDemoStatus('üîÑ Demo reset');
        }

        function showDemoPhotos() {
            // High-quality demo photos with realistic metadata
            const demoPhotoData = [
                {
                    url: 'https://images.unsplash.com/photo-1511895426328-dc8714191300?w=800&h=600&fit=crop&crop=faces',
                    key: 'upload/family-vacation-beach.jpg',
                    lastModified: '2024-07-15T10:30:00Z',
                    size: 2847392,
                    metadata: {
                        title: 'Summer Beach Vacation',
                        description: 'Beautiful family memories from our summer beach vacation. The kids had so much fun building sandcastles and playing in the waves.',
                        tags: ['vacation', 'beach', 'summer', 'family', 'kids']
                    }
                },
                {
                    url: 'https://images.unsplash.com/photo-1530841344095-b2893194affe?w=800&h=600&fit=crop&crop=faces',
                    key: 'upload/birthday-celebration.jpg',
                    lastModified: '2024-08-22T15:45:00Z',
                    size: 3156789,
                    metadata: {
                        title: 'Birthday Celebration',
                        description: 'Celebrating another wonderful year with cake, laughter, and precious family moments.',
                        tags: ['birthday', 'celebration', 'family', 'cake', 'party']
                    }
                },
                {
                    url: 'https://images.unsplash.com/photo-1511632765486-a01980e01a18?w=800&h=600&fit=crop&crop=center',
                    key: 'upload/holiday-dinner.jpg',
                    lastModified: '2024-12-25T18:20:00Z',
                    size: 2934567,
                    metadata: {
                        title: 'Holiday Family Dinner',
                        description: 'Our traditional holiday gathering with delicious food and warm family conversations.',
                        tags: ['holiday', 'christmas', 'family', 'dinner', 'tradition']
                    }
                },
                {
                    url: 'https://images.unsplash.com/photo-1449824913935-59a10b8d2000?w=800&h=600&fit=crop&crop=center',
                    key: 'upload/camping-adventure.jpg',
                    lastModified: '2024-06-10T12:15:00Z',
                    size: 2645123,
                    metadata: {
                        title: 'Camping Adventure',
                        description: 'Weekend camping trip in the mountains with hiking, campfires, and stargazing.',
                        tags: ['camping', 'adventure', 'mountains', 'nature', 'outdoor']
                    }
                },
                {
                    url: 'https://images.unsplash.com/photo-1511895426328-dc8714191300?w=800&h=600&fit=crop&crop=top',
                    key: 'upload/graduation-day.jpg',
                    lastModified: '2024-05-20T16:00:00Z',
                    size: 3421876,
                    metadata: {
                        title: 'Graduation Day',
                        description: 'A proud milestone moment celebrating academic achievement and future possibilities.',
                        tags: ['graduation', 'achievement', 'education', 'milestone', 'proud']
                    }
                },
                {
                    url: 'https://images.unsplash.com/photo-1542038784456-1ea8e935640e?w=800&h=600&fit=crop&crop=center',
                    key: 'upload/weekend-picnic.jpg',
                    lastModified: '2024-09-05T14:30:00Z',
                    size: 2198765,
                    metadata: {
                        title: 'Weekend Family Picnic',
                        description: 'Relaxing weekend picnic in the park with games, good food, and quality family time.',
                        tags: ['picnic', 'weekend', 'park', 'relaxation', 'family']
                    }
                },
                {
                    url: 'https://images.unsplash.com/photo-1511632765486-a01980e01a18?w=800&h=600&fit=crop&crop=bottom',
                    key: 'upload/game-night.jpg',
                    lastModified: '2024-11-08T20:45:00Z',
                    size: 1876543,
                    metadata: {
                        title: 'Family Game Night',
                        description: 'Fun evening playing board games and creating memories together at home.',
                        tags: ['games', 'family', 'fun', 'evening', 'home']
                    }
                },
                {
                    url: 'https://images.unsplash.com/photo-1449824913935-59a10b8d2000?w=800&h=600&fit=crop&crop=faces',
                    key: 'upload/spring-garden.jpg',
                    lastModified: '2024-04-15T11:20:00Z',
                    size: 2567890,
                    metadata: {
                        title: 'Spring Garden Project',
                        description: 'Working together in the garden, planting flowers and vegetables for the new season.',
                        tags: ['spring', 'garden', 'planting', 'flowers', 'teamwork']
                    }
                }
            ];

            // Add demo overlay to photos
            StateManager.setPhotos(demoPhotoData);
            renderPhotos();
            
            // Add demo overlays to photo cards
            setTimeout(() => {
                const photoCards = document.querySelectorAll('.photo-card');
                photoCards.forEach(card => {
                    if (!card.querySelector('.demo-photo-overlay')) {
                        const overlay = document.createElement('div');
                        overlay.className = 'demo-photo-overlay';
                        overlay.textContent = 'DEMO';
                        card.style.position = 'relative';
                        card.appendChild(overlay);
                    }
                });
            }, 100);
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üé≠ Family Photo Gallery Demo Mode initialized');
            
            // Set up state management listeners
            setupStateListeners();
            
            // Initialize UI state
            StateManager.resetState();
            
            // Set up accessibility and keyboard navigation
            setupGlobalKeyboardNavigation();
            
            // Initialize performance optimizations
            optimizePerformance();
            
            // Initialize lazy loading
            initializeLazyLoading();
            
            // Log initial state for debugging
            console.log('Initial state:', StateManager.getState());
            
            // Announce application ready to screen readers
            announceToScreenReader('Family Photo Gallery Demo Mode loaded and ready');
            
            // Demo mode specific initialization
            updateDemoStatus('Demo ready - click buttons to test features');
            
            console.log('üé≠ Demo Mode: Use the demo controls to test all features');
            console.log('üé≠ Available demos: Photo Loading, Architecture Visualization, Error Handling, Loading States');
        });
    </script>
</body>
</html>